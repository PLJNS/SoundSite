---
layout: page
title: Notes
subtitle: From Paul Jones at Rutgers University
---
{% raw %}
<h1 id="principle-of-programming-languages-with-professor-louis-steinberg">Principle of Programming Languages <small>with Professor Louis Steinberg</small></h1>
<h2 id="description">Description</h2>
<p>The course is aimed at making the student familiar with the general concepts common to all programming languages so as to facilitate learning new languages. Language paradigms (i.e., logic, functional, procedural, object-oriented) are compared and implementation strategies are discussed.</p>
<ul>
<li>Credits: 4</li>
<li>Prerequisites:
<ul>
<li>14:332:331 or 01:198:211;</li>
<li>01:198:205 or 14:332:312.</li>
</ul></li>
<li><p>Please note that courses for which a student has received a grade of D cannot be used to satisfy prerequisite requirements.</p></li>
<li><p>Semesters Offered: Spring and fall</p></li>
</ul>
<h3 id="topics">Topics</h3>
<ul>
<li><p>BNF and context free grammars; Data visibility (i.e., lexical and dynamic scoping);</p></li>
<li>Procedures and parameter passing techniques;</li>
<li>Types, type checking and type equivalence;</li>
<li>Functional programming paradigm:
<ul>
<li>higher-order functions,</li>
<li>recursive data structures,</li>
<li>programming with recursion (i.e., without iteration);</li>
</ul></li>
<li>Logic programming paradigm:
<ul>
<li>unification, generate and test;</li>
<li>Programming with pointers in C.</li>
</ul></li>
</ul>
<h3 id="expected-work">Expected Work</h3>
<p>There are three graded programming projects and textbook homework assignments.</p>
<ul>
<li>Exams:
<ul>
<li>1 hourly, Final Exam</li>
</ul></li>
</ul>
<h3 id="department-learning-goals">Department Learning Goals</h3>
<ul>
<li>Computer Science majors ...
<ul>
<li><p>will be prepared to contribute to a rapidly changing field by acquiring a thorough grounding in the core principles and foundations of computer science (e.g., techniques of program design, creation, and testing; key aspects of computer hardware; algorithmic principles).</p></li>
<li><p>will acquire a deeper understanding on (elective) topics of more specialized interest, and be able to critically review, assess, and communicate current developments in the field.</p></li>
<li><p>will be prepared for the next step in their careers, for example, by having done a research project (for those headed to graduate school), a programming project (for those going into the software industry), or some sort of business plan (for those going into startups).</p></li>
</ul></li>
</ul>
<h2 id="syllabus">Syllabus</h2>
<h3 id="objective">Objective</h3>
<ul>
<li><p>Primary objective: Learn new ways of thinking about problems and programs.</p></li>
<li><p>Secondary objective: Make it easier to learn new languages by learning principles that apply to many languages.</p></li>
<li><p>Tertiary objective: Learn some interesting languages.</p></li>
</ul>
<h3 id="prerequisite">Prerequisite</h3>
<ul>
<li>CS 205, CS 211</li>
<li>Java; the memory model of C, including pointers; predicate calculus</li>
</ul>
<h3 id="book">Book</h3>
<ul>
<li>Michael L. Scott, Programming Language Pragmatics, 3rd Edition. Morgan Kaufman</li>
</ul>
<p>**The textbook does not cover all of the material for this course, and is not a substitute for attending class.**</p>
<h3 id="work">Work</h3>
<ul>
<li><p>You are expected to attend all lectures and recitations, in both body and mind. That is, please do not access Facebook, games, email, or the like during class.</p></li>
<li><p>There will be two midterms exams and a final, as well as graded programing projects and ungraded exercises. The projects only count for a small part of your grade directly, because there is no way to be sure that they are really your own work. However, they count for a large part of your grade indirectly. If you do not do the exercises and projects you will not learn the material. Furthermore, there will be exam questions directly based on the projects and exercises.</p></li>
</ul>
<h3 id="tentative-grading">Tentative Grading</h3>
<p>Your course grade is based on projects and exams, with the following tentative weighting:</p>
<ul>
<li>Projects (all together): 10%</li>
<li>Midterm 1: 25%</li>
<li>Midterm 2: 25%</li>
<li>Final exam: 40%</li>
</ul>
<h3 id="course-grades">Course grades</h3>
<p>Your course grade will be computed as follows: Each score (for each exam and each project) will be converted to a percentage score, and the percentages will be added, with weights as above. Cutoffs for letter grades are:</p>
<ul>
<li>A: 90%</li>
<li>B+: 85%</li>
<li>B: 80%</li>
<li>C+: 75%</li>
<li>C: 70%</li>
<li>D: 60%</li>
</ul>
<h3 id="grading-disputes">Grading disputes</h3>
<p>If you feel an exam or a project has been misgraded, you must bring it to our attention within 2 weeks of when we first give back the graded exam or project.</p>
<h3 id="collaboration">Collaboration</h3>
<p>All students in this class are expected to be familiar with the The DCS academic integrity policy, which can be found at http://www.cs.rutgers.edu/policies/academicintegrity/ , and to abide by it.</p>
<p>We do encourage you to us the Piazza site to discuss the concepts behind course material and assignments, but please do not post code. If you need help with code, email it to the professor or a TA.</p>
<h3 id="exams">Exams</h3>
<p>Exam schedules and rules are in Resources &gt; Exam info. You are expected to know and to abide by these rules.</p>
<h3 id="poor-grades">Poor grades</h3>
<p>If you get less than 70% on an exam please contact the 314 TA's or instructor immediately. Often students wait until after the final, and then ask how they can raise their grade. At that point there is no way to raise their grade. The earlier you contact us the more chance we can be of help.</p>
<h3 id="topics-1">Topics</h3>
<p>The following list is organized by topic, not by chronological order of coverage in the course.</p>
<ol style="list-style-type: decimal">
<li>Formal Languages
<ul>
<li>Context free grammars</li>
<li>Regular grammars</li>
<li>Finite state automata</li>
<li>Regular expressions</li>
<li>Using all of the above to define a language</li>
<li>Functional Programming</li>
</ul></li>
<li>Scheme
<ul>
<li>Repetition through recursion, not iteration</li>
<li>Stateless programming</li>
<li>Closures</li>
<li>Continuations and coroutines.</li>
<li>Logic Programming</li>
</ul></li>
<li>Prolog
<ul>
<li>Scripting</li>
</ul></li>
<li>Python
<ul>
<li>Principles</li>
<li>Types and type inference</li>
<li>Scope &amp; binding,lexical and dynamic</li>
<li>Parameter passing modes</li>
</ul></li>
</ol>
<h2 id="september-16th-2013-assignment-1">September 16th, 2013 <small>Assignment 1</small></h2>
<ol style="list-style-type: decimal">
<li><p>Given grammar <code>G</code>: (capitals are non-terminals, everything else is a terminal)</p>
<pre><code>S -&gt; A | S # S | S @ S      
A -&gt; C | C A        
C -&gt; a | b | c</code></pre>
<ul>
<li>For each of the strings below:
<ol style="list-style-type: decimal">
<li><p>if it is in <code>L(G)</code> prove it by giving both - a leftmost derivation</p></li>
<li><p>a parse tree. If it is ambiguous demonstrate that fact with parse trees.</p></li>
<li><p>if it is not in <code>L(G)</code> say so and explain why</p></li>
</ol></li>
<li>Strings:
<ol style="list-style-type: decimal">
<li><code>aa # bb</code>
<ol style="list-style-type: decimal">
<li><code>S</code></li>
<li><code>S # S</code></li>
<li><code>A # A</code></li>
<li><code>C # C</code></li>
<li><code>a # a</code></li>
</ol></li>
<li><code>a @ b # c</code>
<ol style="list-style-type: decimal">
<li><code>S</code></li>
<li><code>S # S</code></li>
<li><code>S # S @ S</code></li>
<li><code>A # A @ A</code></li>
<li><code>C # C @ C</code></li>
<li><code>a @ b # c</code></li>
</ol></li>
<li><code>ab</code>
<ol style="list-style-type: decimal">
<li><code>SS</code></li>
<li><code>AA</code></li>
<li><code>CC</code></li>
<li><code>ab</code></li>
</ol></li>
</ol></li>
</ul></li>
<li><p>Rewrite the grammar <code>G</code> above so that no string in its language is ambiguous. Make # have higher precedence than <code>@</code> and make both <code>#</code> and <code>@</code> be left-associative.</p>
<pre><code>S -&gt; A | @ S       
A -&gt; C | # A        
C -&gt; a | b | c</code></pre></li>
<li><p>Given grammar G':</p>
<pre><code>S -&gt; A B
A -&gt; x | A a
B -&gt; y | b B</code></pre>
<ol style="list-style-type: decimal">
<li>Give a string that is in <code>L(G')</code> and one that is not
<ol style="list-style-type: decimal">
<li><code>xy</code></li>
<li><code>x</code></li>
</ol></li>
<li><p>Describe in English what strings are in <code>L(G')</code>.</p>
<p><code>L(G')</code> contains a series of <code>x</code>s followed by a series of <code>y</code>s, each with at least one <code>x</code> or <code>y</code> followed by potentially infinite <code>x</code>s or <code>y</code>s.</p></li>
</ol></li>
<li><p>Let <code>L1</code> be a formal language using the binary digits <code>0</code> and <code>1</code> as its character set, such that a string is in <code>L1</code> if and only if it has <code>3</code> or more <code>1</code>'s in a row somewhere in it.</p>
<ol style="list-style-type: decimal">
<li><p>Draw a deterministic finite state automaton that recognizes <code>L1</code>.</p>
<pre><code>    +---+    +---+    +---+    +---+
  -&gt;| 1 |---&gt;| 1 |---&gt;| 1 |---&gt;| 0 |
    +---+    +---+    +---+    +---+
    |                  |       |
    ---------------------------+</code></pre></li>
<li><p>Write a regular expression whose language is <code>L1</code>.</p>
<pre><code>/([01]*[111]+[01]*)/</code></pre></li>
</ol></li>
<li><p>Let <code>L3</code> be a formal language using the letters <code>o</code>, <code>a</code>, and <code>y</code>, such that a string is in <code>L3</code> if and only if it has the string <code>yoya</code> somewhere within it.</p>
<ol style="list-style-type: decimal">
<li><p>Draw a nondeterministic FSA that recognizes <code>L3</code>.</p>
<pre><code>      ______________________         _
      |         |          |        | |
    +---+ o  +----+ y  +-----+ a  +------+
  -&gt;| y |---&gt;| yo |---&gt;| yoy |---&gt;| yoya |
    +---+    +----+    +-----+    +------+</code></pre></li>
<li><p>Write a regular expression whose language is <code>L3</code>.</p>
<p>(y|o|a)<em>(yoya)+(y|o|a)</em></p></li>
</ol></li>
<li><p>Describe in English the language accepted by this DFSA: <code>S1</code> is the start state and only <code>S2</code> is an accepting state.</p>
<p>A series of zeroes and ones with at least a single one and possibly no zeroes.</p></li>
<li>Describe in English the language of each of the following RE's:
<ol style="list-style-type: decimal">
<li><code>ab*c*</code>
<ul>
<li>This is a series <code>b</code>s preceded by an <code>a</code>, followed by any number of <code>c</code>s.</li>
</ul></li>
<li><code>a*|b*</code></li>
</ol>
<ul>
<li>Any number of <code>a</code>s followed by any number of <code>b</code>s.</li>
</ul>
<ol style="list-style-type: decimal">
<li><code>(ab)*</code></li>
</ol>
<ul>
<li>A possibly empty series of repeating <code>ab</code>.</li>
</ul></li>
</ol>
<h2 id="september-23rd-2013-assignment-2">September 23rd, 2013 <small>Assignment 2</small></h2>
<ol style="list-style-type: decimal">
<li>View the video: https://www.youtube.com/watch?v=prAwkQt3ARg</li>
<li>Answer these questions:
<ol style="list-style-type: decimal">
<li>What is the main point the speaker is trying to make</li>
<li>List two examples the speaker uses and explain for each how it supports his point, or, if you think that it does not, why not.</li>
</ol></li>
</ol>
<h2 id="october-3rd-2013-exercise-4-scheme">October 3rd, 2013 <small>Exercise 4: Scheme</small></h2>
<p>For these problems, you must use pure functional scheme. That is: You may not use a functions like set! whose name ends with '!'. You may not use for or while loops or do loops. All repetition must be via explicit recursion or the recursion implicit in map or similar functions. (You can do problems 1 – 3 before we cover map in class.) You may, however, use define – in fact you must use it. You may use any implementation of scheme that complies with the R5RS standard.</p>
<ol style="list-style-type: decimal">
<li><p>Write the function echo. This function doubles each top-level element of it argument. E.g., (echo '(a b c)) returns (a a b b c c). (echo '(a (b c))) returns (a a (b c) (b c))</p></li>
<li><p>Write the function nth. (nth i lst) returns the ith element of lst. E.g., (nth 0 '(a b c)) returns a, (nth 1 '(a b c)) returns b. You may assume that 0 ≤ i &lt; (length lst).</p></li>
<li><p>Write the function deep-reverse, which reverses its argument at all levels. E.g., (deep-reverse '(a (b c) (d))) returns ((d) (c b) a).</p></li>
<li><p>Write a scheme function (assoc-all lst a-list) where lst is a list of symbols and a-list is an assoc-list. assoc-all returns a list of the data associated with elements of lst by assoc-list. E.g. (assoc-all '(a d c d) '((a apple)(b boy)(c cat)(d dog))) returns (apple dog cat dog). Use map. Note that you can't simply use assoc as one of the arguments to map. You need a lambda.</p></li>
<li><p>Write a function filter-evens which takes a list of numbers as its argument and returns a new list containing only the even numbers in the input list. E.g., (filter-evens '(23 33 44 2 1 8)) returns (44 2 8). Use even? to test if a number is even. You must use map. You may use a helper function but the only recursion should be the recursion implicit in map. Hint: Note that the result of map is exactly as long as its second argument. E.g. the result of (map foo '(23 33 44 2 1 8)) will be a list of 6 elements no matter what function foo is. So how can this problem be solvable? Do something to the result of map before you return it. E.g., suppose the result of (map foo '(23 33 44 2 1 8)) is ( ( ) ( ) (44)(2)( ) (8)). Then (apply append (map foo '(23 33 44 2 1 8))) will result in (44 2 8) .</p></li>
</ol>
<h2 id="october-15th-2013-midterm-1-study-guide">October 15th, 2013 <small>Midterm 1 Study Guide</small></h2>
<h3 id="formal-languages">Formal Languages</h3>
<h4 id="grammars">Grammars</h4>
<ul>
<li><p><strong>Parsing</strong> works from the terminal string to the start</p>
<pre><code>terminal string =&gt; ... =&gt; &lt;start&gt;</code></pre>
<ul>
<li>A <strong>parse-tree</strong> has internal nodes as nonterminals, where the children make up the right-hard side of one of the productions for that nonterminal.</li>
</ul></li>
<li><p><strong>Derivation</strong> works from the start and <em>to</em> the terminal string</p>
<pre><code>&lt;start&gt; =&gt; ... =&gt; terminal string</code></pre></li>
<li>ambiguity and removing ambiguity:
<ul>
<li><p>To add <strong>precedence</strong> to a parse tree, make the edge &quot;higher in the tree&quot; where higher means lower precedence.</p></li>
<li><p><strong>Associativity</strong> can distinguish <code>a ~ b ~ c</code> in two ways: 1. <code>(a ~ b) ~ c</code> or 2. <code>a ~ (b ~ c)</code>.</p></li>
</ul></li>
<li><strong>Regular grammars</strong> are used to specify the structure of tokens.</li>
<li><p><strong>Context-free grammars</strong> are used to specify the overall structure of a programming language.</p></li>
</ul>
<h4 id="regular-expressions">Regular Expressions</h4>
<ul>
<li>The letter itself represents just itself.</li>
<li>The empty string represents just itself.</li>
<li>The &quot;or&quot; operator will union the sets of two definitions.</li>
<li><p>Placing to expressions next to one another will place both sets right next to each other, &quot;Cartesian product.&quot;</p></li>
<li><p>Two letters next to one another contain only those two letters.</p>
<pre><code>a             {a}
e             {e}
R|S           L_r U L_s
a|b           {a, b}
RS            L_r L_s
ab            {ab}</code></pre></li>
<li><p><code>*</code> will make the represented set the empty string and any number of the contained expression.</p></li>
<li><p><code>+</code> will make any number of the contained expression excluding the empty string.</p>
<pre><code>a             {a}
b             {b}
ab            {ab}
a|b           {a, b}
ab|ac         {ab, ac}
(a|b)(b|c)    {ac, ad, bc, bd}
(abc|e)d      {abcd, ed}

a*            {e, a, aa, aaa, ...}
ab*           {a, ab, abb, abbb, ...}
(ab)*         {e, ab, abab, ababab, ...}
(a|b)*        {e, a, b, aa, ab, ba, bb, ...}
a+            {a, aa, aaa, ...} 
ab+           {ab, abb, abbb, etc}</code></pre></li>
<li>is this string in the language defined by this regular expression?</li>
<li>describe in English the language defined by this regular expression</li>
<li><p>write an regular expression that defines this language</p></li>
</ul>
<h4 id="finite-state-automata">Finite State Automata</h4>
<ul>
<li>An <strong>automaton</strong> is a machine <em>which corresponds to a language</em>.
<ul>
<li>it <em>inputs</em> a <em>string</em>, one character at a time.</li>
<li>it <em>outputs</em> a <em>boolean</em>: is the string in the language?</li>
</ul></li>
<li><p><strong>Finite automata</strong> accepts or recognizes an input string if and only if there exists a path from its start state to a final state such that the labels on the path are the terminals in that string.</p></li>
<li>To construct a <strong>nondeterministic</strong> finite state automata,
<ol style="list-style-type: decimal">
<li>Allow more than one transition with the same label.</li>
<li>Allow <em>ε</em> transition</li>
<li>Recognize an input string just in case there exists <em>some</em> path from start state to a final state such that the labels on the path are the terminals in the string.</li>
</ol></li>
<li><p>If the finite state automata does not follow these rules, it is a <strong>deterministic</strong> finite state automata.</p></li>
</ul>
<h5 id="types-of-questions">Types of questions</h5>
<ul>
<li>is this string accepted by this finite automata?
<ul>
<li>To solve this, use the starting state as the first letter in the string and only go through those states with edges with ensuing letters. If there exists no path from the start state to a valid end state through existing edges, then the string is not valid.</li>
</ul></li>
<li>describe in English the language accepted by the finite automata.
<ul>
<li>To solve this, step through a few possible and valid paths for the FSA and generalize from the pattern.</li>
</ul></li>
<li>write an finite automata that accepts this language</li>
</ul>
<h3 id="functional-programming-scheme">Functional Programming &amp; Scheme</h3>
<ul>
<li>shallow and deep recursion on lists</li>
<li>accumulator recursion and tail recursion</li>
<li>lambda and closures</li>
<li>functions that take functions as arguments
<ul>
<li>apply, map, foldr, plot, compose, etc.</li>
</ul></li>
<li>functions that return functions
<ul>
<li>null-safe, repeat-cols, add-check</li>
<li>encapsulating patterns</li>
</ul></li>
<li>functions stored in data structures</li>
</ul>
<h3 id="midterm-fall-2011">Midterm Fall 2011</h3>
<ol style="list-style-type: decimal">
<li><p>Consider the Finite State Automaton (FSA) defined by the following diagram:</p>
<ul>
<li>Is this FSA deterministic or non-deterministic? Why?
<ul>
<li>The necessary and sufficient conditions for a NFA are at least one <em>ε</em> or multiple state transitions (multiple edges).</li>
</ul></li>
<li>Write a Regular Expression that specifies the same language as the FSA</li>
</ul></li>
<li><p>Consider the following grammar, <code>G1</code>:</p>
<pre><code>S   =&gt; Foo # S | Foo
Foo =&gt; Foo % Fie | Fie
Fie =&gt; 0 | 1 | a | b | ( S )</code></pre>
<ul>
<li><p>Draw a parse tree to show that</p>
<pre><code>a # b % 1</code></pre>
<p>is in the language of <code>G1</code></p>
<pre><code>          S
      Foo # S
      Fie # Foo
     a  # Foo % Fie
     a  # Fie % 1
     a   # b   % 1</code></pre>
<p>Roughly, a methodology for solving these is to begin with whatever your start symbol is on scratch paper, write at the bottom whatever your desired expression is, and fill in the paths using your fantastic powers of intuition and foresight as a human being. This would be harder to do algorithmically than intutively for small cases, I suspect.</p></li>
<li><p>Add parentheses to the following to show the order of operations implied by <code>G1</code>.</p>
<ul>
<li><code>(a % b) % 0</code></li>
<li><code>0 # (1 % a)</code></li>
<li>I think the strategy to solve these is to begin with the &quot;deepest&quot; level of the language, the furthest from the starting expression, and those expressions that are together there are &quot;implied&quot; to be connected with higher precedence than those are higher levels. Because the <code>#</code> is &quot;higher&quot; than the <code>%</code> operator, it's precedence is lower.</li>
</ul></li>
</ul></li>
<li><p>Describe in English the language accepted by the following Nondeterministic Finite State Automaton. The start state is D. The only accepting state is F.</p></li>
<li><p>The function <code>(repeat n x)</code> returns a list of <code>n</code> copies of <code>x</code>. E.g., <code>(repeat 3 'w)</code> should return <code>(w w w)</code>. <code>(repeat 2 '(a b))</code> returns <code>((a b) (a b))</code>. If <code>n</code> is <code>0</code> repeat should return <code>( )</code>.</p>
<pre><code>;WRONG:
(define (repeat n x)
    (if (eq? n 0)
        x                             ; this a number, not a list
        (repeat (- n 1) (append x x)) ; this is just shitty, but ...
    )
)

;RIGHT:
(define (repeat n x) 
    (if (eq? n 0)                 ; if n == 0
        &#39;()                       ; return the empty list
        (cons (repeat (- n 1) x)) ; else build a list with the return value
                                  ; of repeat(n - 1, x)
    )
)</code></pre></li>
<li><p>The function <code>(deep-member x lst)</code> returns true if <code>x</code> is a member of list <code>lst</code> at any depth and false otherwise. E.g., <code>(deep-member 's '(e r ((x s) t))</code> returns <code>#t</code> (true) while <code>(deep-member 'a '(e r ((x s) t)))</code> returns <code>#f</code> (false). You may assume <code>x</code> is a number or symbol, not a list.</p>
<pre><code>(define (deep-member x lst)
    (if (null? lst)
        #f
        (if (eq? (car lst) x)
            #t
            (or (deep-member x (cdr lst)) (deep-member x ()))
        )
    )
)</code></pre></li>
<li><p>Define <code>(for-n start stop fn)</code>. It takes three arguments: start and stop, which are numbers, and fn which is a function of one argument. <code>For-n</code> calls <code>fn</code> several times, first with the argument <code>start</code>, then with <code>start+1</code> then ... finally with <code>stop</code>. It returns a list of the results of these calls. If <code>start &gt; stop</code>, <code>for-n</code> simply returns the empty list without doing any calls to <code>fn</code>.</p>
<pre><code>(define (for-n start stop fn)
    (if (&gt; start stop)
        &#39;()
        (cons (fn start) (for-n (+ start 1) stop fn))
    )
)</code></pre></li>
<li><p><code>(protect-zero fn)</code> takes one argument, <code>fn</code>, a function which itself takes one argument. The value of <code>protect-zero</code> is also a function of one argument. Let us call this the result function. If its argument is not <code>0</code>, the result function just calls <code>fn</code> and returns whatever <code>fn</code> returns. If the result function's argument is <code>0</code>, it does not call <code>fn</code> but instead returns the symbol <code>OOPS</code>.</p>
<pre><code>(define (protect-zero fn)

)</code></pre></li>
</ol>
<h3 id="midterm-fall-2012">Midterm Fall 2012</h3>
<ol style="list-style-type: decimal">
<li><p>Consider the Finite State Automaton (FSA) defined by the following transition table:</p>
<ul>
<li>Is this FSA deterministic or non-deterministic? Why?</li>
<li><p>Complete the following grammar. It must specify the language accepted by the FSA above.</p></li>
<li><p>Write a Regular Expression that specifies the same language as the FSA above.</p></li>
</ul></li>
<li><p>Suppose a language had logical expressions using the operators \^ and v, with ^ having higher precedence. The letters t and f are constants and p and q are variables. An expression of the form <value> ^ <value> ^ <value> means (<value> ^ <value>) ^ <value> and <value> v <value> v <value> means <value> v (<value> v <value>) Complete the following grammar for these expressions.</p></li>
<li><p>Write scheme functions for each of the following. You may write additional helper functions if you wish.</p>
<ol style="list-style-type: decimal">
<li><p>Function countFie takes a list as its argument and returns a count of how many times the symbol fie appears as a top-level element in the list. E.g., (countFie ‘(a fie (fie b) fie)) returns 2. Use recursion, but not higher-order functions, e.g. not map.</p>
<pre><code>(define (countFie lst)                ; function definition
    (if (null? lst)                   ; base case
        0                             ; base case return value
        (if (eq? (car lst) &#39;fie)      ; current equal &quot;fie&quot;?
            (+ 1 (countFie (cdr lst))); then return 1 plus the rest
            (countFie (cdr lst))      ; else keep counting
        )
    )
)</code></pre></li>
<li><p>Write (countAllFie lst) takes a list and returns a count of how many times the symbol fie appears at any level of the list. E.g., (countAllFie '(fie foo ((fie 3)))) returns 2. (countAllFie 'fie) returns 1. Your definition must use map.</p></li>
<li><p>Finish the function add-squares-h below. Add-squares-h is a helper function for add-squares. Add-squares takes a list of numbers and returns the sum of the squares of these numbers. E.g., (add-squares '(3 4)) returns 25. Accum is an accumulator. Add-squares-h must be tail-recursive.</p>
<pre><code>(define (add-squares lst) (add-squares-h lst 0)) ; given
(define (add-squares-h lst accum)                ; given
    (if (eq? lst null)                           ; if list is null
        accum                                    ; then return accum
        (add-squares-h (cdr lst) ; otherwise, call a-s-q on the next lst
                       (+ accum (* (car lst) (car lst))) ; can square the
                                                         ; current thing
        )
    )
)</code></pre></li>
<li><p>Define (compose f g) The arguments f and g are each a function of one argument. The value returned by compose is a function, the composition of f and g. That is, ((compose (lambda (x) (+ 1 x))(lambda (x)(* x x))) 5) returns 26.</p>
<pre><code>(define compose(f g) ; definition line
    (lambda(x)       ; this returns a function, need lambda
        (f(g x))     ; perform `f` on return of performing `g` on `x`
    )
)</code></pre></li>
</ol></li>
</ol>
<h2 id="october-26th-2013-exercise-set-5-prolog">October 26th, 2013 <small>Exercise Set 5: Prolog</small></h2>
<ol style="list-style-type: decimal">
<li><p>Translate the following into a set of prolog facts and rules. It should be possible for Prolog to infer 5 from 1 through 4.</p>
<ol style="list-style-type: decimal">
<li><p>Joe is in the toy department</p>
<pre><code>inside(joe, toy_dept).</code></pre></li>
<li><p>If someone is in a department they report to the head of that department.</p>
<pre><code>report(X, Y, dept) :- inside(x, dept), head(y, dept). </code></pre></li>
<li><p>Sam is the head of the toy department.</p>
<pre><code>head(sam, toy_dept).</code></pre></li>
<li><p>Everyone's salary is less that the salary of the person they report to.</p>
<pre><code>paid_less(X, Y) :- report(X, Y, Z).</code></pre></li>
<li><p>Joe's salary is less than Sam's salary.</p>
<pre><code>paid_less(joe, sam).</code></pre></li>
</ol></li>
<li><p>Write a definition in Prolog for the predicate <code>fib(N, F)</code> which is true if <em>F</em> is the <em>N</em>th fibonacci number, <em>f<strong>i</strong>b</em><sub><em>N</em></sub>, defined as follows: <em>f<strong>i</strong>b</em><sub>0</sub> is 0, <em>f<strong>i</strong>b</em><sub>1</sub> is 1, and for <em>N</em> &gt; 1,</p>
<p><em>f<strong>i</strong>b<strong>N<em> = </em>f</strong>i<strong>b</strong>N</em> − 1 + *f<strong>i</strong>b**N* − 2</p>
<pre><code>fib(0, 0).
fib(1, 1).
fib(N, F) :- A is N - 1, 
    B is N - 2,fib(A, AF), 
    fib(B, BF),NF is AF + BF.</code></pre></li>
<li><p>Write a definition in Prolog for the predicate double, where double(A, B) is true for lists A and B if B has the same elements as A, but repeated. E.g. double([dog, cat], [dog, dog, cat, cat]) is true, but double([dog, cat], [dog, cat, dog, cat] is not true. double([dog, cat], L) should bind L to [dog, dog, cat, cat]. The query double([a, b], L). should succeed, binding L to [1, 1, b, b].</p>
<pre><code>double_up([], []).
double_up([A | As], [A, A | Rest]) :- double_up(As, Rest).

double([], []).
double(A, B) :- double_up(A, A) = B.</code></pre></li>
<li><p>Write a definition in Prolog for the predicate without0(L1, L2) which is true if L2 is a copy of L1 with all 0's removed. E.g., without0([4, 0, 5, 6, 0], [4, 5, 6]) is true and without0([4, 0, 5],</p>
<ol style="list-style-type: decimal">
<li><p>binds L to [4, 5].</p>
<p>remove0([], A, []). remove0([H | T], A, Result) :- H = A, remove0(T, A, Result). remove0([H | T], A, [H | Result]) :- remove0(T, A, Result).</p>
<p>without0([], []). without0(A, B) :- remove0(A,0,Result), Result = B.</p></li>
</ol></li>
</ol>
<h2 id="october-19th-2013-logic-programming">October 19th, 2013 <small>Logic Programming</small></h2>
<dl>
<dt>Constants</dt>
<dd><p>Represent entities, which are &quot;things&quot; and not functions or relations.</p>
</dd>
<dd><p>In Prolog, start with lower case.</p>
<pre><code>albert, my_house</code></pre>
</dd>
<dt>Variables</dt>
<dd><p>Stands for constants</p>
<p>In Prolog, start with upper case or <code>_</code></p>
<pre><code>X, House, _xyz, _321</code></pre>
</dd>
<dt>Functors</dt>
<dd><ul>
<li>Represent a function from entities to an entity.
<ul>
<li>&quot;Function&quot; = &quot;Mapping&quot; as in math, not a computation.</li>
</ul></li>
</ul>
</dd>
<dd><ul>
<li>In Prolog, start with lower case like constants.
<ul>
<li>In fact, a constant is just a term with no arguments.</li>
</ul></li>
</ul>
</dd>
<dt>Terms</dt>
<dd><p>Represent an entity.</p>
</dd>
<dd><ul>
<li>Constant, variable, or <code>&lt;functor&gt;[(&lt;term&gt; {, &lt;term&gt;})]</code>
<ul>
<li><code>father(albert)</code> might represent the father of albert</li>
<li><p><code>successor(victoria)</code> might represent the successor of victoria</p></li>
<li><p><code>sum(1, 2)</code> might represent the sum of 1 and 2</p></li>
</ul></li>
</ul>
</dd>
<dt>Predicates</dt>
<dd><p>Represent a function from entity (terms) to a boolean.</p>
</dd>
<dd><p>In Prolog, start with lower case like functors.</p>
</dd>
<dt>Atoms</dt>
<dd><p>Logical statement without and, or, not, etc.</p>
<pre><code>&lt;predicate&gt;(&lt;term&gt; {, &lt;term&gt;})
older( father(Person), Person) 
square(X, 4)</code></pre>
</dd>
<dt>Horn clauses</dt>
<dd><p>A horn clause is</p>
<pre><code>c h1 ^ h2 ^ h3 ^ ... ^ h_n</code></pre>
<dl>
<dt>Antecedent <code>h</code></dt>
<dd><p>Conjunction of zero or more conditions which are *atomic formulas*.</p>
<p>Alternatively, <strong>subgoal</strong> or <strong>tail</strong>.</p>
</dd>
<dt>Consequent <code>c</code></dt>
<dd><p>The consequent is true just in case all the antecedents are true.</p>
<p>Alternatively, called <strong>goal</strong> or <strong>head</strong>.</p>
</dd>
</dl>
</dd>
<dd><p>Written as,</p>
<pre><code>c :- h1 , ... , hn.</code></pre>
</dd>
<dd><p>A horn clause with no tail is a <strong>fact</strong>.</p>
<p>A horn clause with tail is a <strong>rule</strong>.</p>
</dd>
<dt>List</dt>
<dd><p>A sequence of elements separated by commas.</p>
<pre><code>[ first element | rest_of_list ]</code></pre>
<table>
<thead>
<tr class="header">
<th align="left">list</th>
<th align="left">head</th>
<th align="left">tail</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>[a, b, c]</code></td>
<td align="left"><code>a</code></td>
<td align="left"><code>[b, c]</code></td>
</tr>
<tr class="even">
<td align="left"><code>[X,[cat],Y]</code></td>
<td align="left"><code>X</code></td>
<td align="left"><code>[[cat],Y]</code></td>
</tr>
<tr class="odd">
<td align="left"><code>[a,[b, c],d]</code></td>
<td align="left"><code>a</code></td>
<td align="left"><code>[[b,c],d]</code></td>
</tr>
<tr class="even">
<td align="left"><code>[X | Y]</code></td>
<td align="left"><code>X</code></td>
<td align="left"><code>Y</code></td>
</tr>
</tbody>
</table>
</dd>
<dd><p>List functions:</p>
<ul>
<li><code>append</code></li>
<li><code>last</code></li>
<li><code>reverse</code></li>
<li><code>reverse-conc</code></li>
</ul>
</dd>
<dt>Member Function</dt>
<dd><dl>
<dt>Goal-oriented semantics</dt>
<dd><p>can get value assignment for goal member(A,[B|C]) by showing truth of subgoal member(A,C) and retaining value bindings of the variables</p>
</dd>
<dt>Procedural semantics</dt>
<dd><p>think of head of clause as procedure entry, terms as parameters. then body consists of calls within this procedure to do the calculation. variables bindings are like &quot;returned values&quot;.</p>
</dd>
</dl>
</dd>
</dl>
<h2 id="october-29th-2013-quickndirty-prolog-tutorial">October 29th, 2013 <small><a href="http://www.cs.utexas.edu/~cannata/cs345/Class%20Notes/12%20prolog_intro.pdf">Quick'n'Dirty Prolog Tutorial</a></small></h2>
<h3 id="prolog-program-components">Prolog Program Components</h3>
<ul>
<li>A <strong>fact</strong> is a <em>single piece of information</em>.
<ul>
<li><p>To represent that the sky is blue, you would write:</p>
<pre><code>blue(sky).</code></pre></li>
<li>Simiarly, <code>mammal(rabbit).</code> says that rabbits are mammals.</li>
<li><p>Facts can have multiple arguments,</p>
<pre><code>plays(john, hockey).</code></pre>
<p>Which represents that John plays hockey.</p></li>
</ul></li>
</ul>
<blockquote>
<p>Prolog constants are in lower case, variables are in upper case, domains are not defined explicitly, and entries always end with a period.</p>
</blockquote>
<ul>
<li><p><strong>Rules</strong> are used to generate new information from facts, other rules, and themselves. They have the form:</p>
<pre><code>head :- body.</code></pre>
Where the head and the body are clauses that typically use variables instead of constants.
<ul>
<li><p>For instance, consider the rule:</p>
<pre><code>grandparent(X, Z) :- parent(X, Y), parent (Y, Z).</code></pre>
The rule says that <code>X</code> is the grandparent of <code>Z</code> when <code>X</code> is a perent of <code>Y</code> and <code>Y</code> is a parent of <code>Z</code>.</li>
<li><p>Rules can be recursive. Consider:</p>
<pre><code>ancestor(X,Y) :- parent(Z,Y), ancestor(X,Z).</code></pre></li>
</ul></li>
<li><p>Now there are <strong>queries</strong>. When you want to ask Prolog a question, you supply a query.</p>
<ul>
<li><p>Queries are like rules without bodies. Prolog will take the head and find out if it is true or false.</p></li>
<li><p>If the query has variables, Prolog will attempt to find all possible values that can be used in place of the variables to make the query true and tell you what they are.</p></li>
<li><p>Consider the database:</p>
<pre><code>parent(amy,bob).
parent(bob,cathy).
parent(bob,doug).
grandparent(X,Z) :- parent(X,Y) , parent(Y,Z).
ancestor(X,Y) :- parent(X,Y).
ancestor(X,Y) :- parent(Z,Y) , ancestor(X,Z).</code></pre>
<ul>
<li>The query <code>parent(amy,bob)</code> will be true.</li>
<li>The query <code>ancestoru(bob, doug)</code> is also true.</li>
<li>The query <code>parent(bob,X)</code> will return all the facts that would make the query true.</li>
</ul></li>
</ul></li>
</ul>
<h3 id="connecting-prolog-to-predicate-logic">Connecting Prolog to Predicate Logic</h3>
<ul>
<li>Think of the <code>:-</code> symbol in Prolog as representing the word &quot;if&quot;.
<ul>
<li><p>Interanlly, Prolog represents rules in a form known as **horn clauses**. These are the disjuction of predicates in which at most one of the predicates is not negated. Consider the grandparent clause:</p>
<pre><code>grandparent(X,Z) :- parent(X,Y) , parent(Y,Z).</code></pre></li>
<li><p>Rewritten in logical notiation,</p>
<p>∀ <em>x</em>∀ <em>y</em>∀ <em>z</em>((<em>P</em>(<em>x</em>, <em>y</em>) ∧ <em>P</em>(<em>y</em>, <em>z</em>)) → <em>G</em>(<em>x</em>, <em>z</em>))</p></li>
<li><p>We know that <em>p</em> → <em>q</em> ≡ ¬<em>p</em> ∨ <em>q</em>, so the above is also:</p>
<p>∀ <em>x</em>∀ <em>y</em>∀ <em>z</em>(¬(<em>P</em>(<em>x</em>, <em>y</em>) ∧ <em>P</em>(<em>y</em>, <em>z</em>)) ∨ <em>G</em>(<em>x</em>, <em>z</em>))</p></li>
<li><p>Apply de Morgans for a horn clause:</p>
<p>∀ <em>x</em>∀ <em>y</em>∀ <em>z</em>(¬<em>P</em>(<em>x</em>, <em>y</em>)¬<em>P</em>(<em>y</em>, <em>z</em>) ∨ <em>G</em>(<em>x</em>, <em>z</em>))</p></li>
</ul></li>
</ul>
<h2 id="november-9th-2013-midterm-2-study-guide">November 9th, 2013 <small>Midterm 2 Study Guide</small></h2>
<h3 id="textbook-chapter-11.2-prolog">Textbook <small>Chapter 11.2 <em>Prolog</em></small></h3>
<h4 id="introduction">Introduction</h4>
<ul>
<li>A Prolog interpreters runs in the context of <em>databases</em> and <em>clauses</em> that are assumed to be true.
<ul>
<li>Each clause is composed of <em>terms</em>, which may be constants variables, or <em>structures</em>.</li>
<li>A constant is either an tom or a number.</li>
<li>A Structure can be thought of as either a logical predicate or data structure.</li>
</ul></li>
<li>Atoms in Prolog looks like an identifier beginning with a lowercase letter, a sequences of &quot;punctuation&quot; characters.</li>
<li>Variables can be <em>instantiated</em>.</li>
<li><p>Structures consist of an atom called a <em>functor</em> and a list of arguments:</p>
<pre><code>rainy(rochester).
teaches(scott, cs254).
bin_tree(foo(bin_tree(bar, glarch))).</code></pre></li>
<li>Prolog requires the opening parenthesis to come immediately after the functor, with no intervening space.
<ul>
<li>Arguments can be arbitrary terms: constants, variables, or nested structures.</li>
<li>We use the term <em>predicate</em> to refer to the combination of a functor and an arity.</li>
</ul></li>
<li>The clauses in a Prolog database can be classified as <em>facts</em> or <em>rules</em>, each of which ends with a period.
<ul>
<li>A fact is a horn clause without a right-hand side.</li>
</ul></li>
<li><p>A rule has a right hand side:</p>
<pre><code>snowy(X) :- rainy(X), cold(X).</code></pre></li>
<li>The token <code>:-</code> is the implication symbol.
<ul>
<li>The comma indicates &quot;and.&quot;</li>
<li>Variables that appear in the head of a Horn clause are universally quantified: for all <code>X</code>, <code>X</code> is snowy is <code>X</code> is raining and <code>X</code> is cold.</li>
</ul></li>
<li>It is possible to write a clause with an empty left-hand side. Such a clause is called a <em>query</em> or a <em>goal</em>.
<ul>
<li>Queries do not appear in Prolog programs.
<ul>
<li>Rather, one build a database of facts and rules and then initiates execution by giving the Prolog interpreter a query to be answered.</li>
</ul></li>
</ul></li>
<li><p>It most implementation of Prolog, queries are entered with a special <code>?-</code> version of the implication symbol. An example:</p>
<pre><code>rainy(seattle).
rainy(rochester).
?- rainy(C).</code></pre>
<ul>
<li><p>The Prolog interpreter would respond with:</p>
<pre><code>C = seattle</code></pre></li>
<li>Of course, <code>C = rochester</code> would also be a valid answer, but Prolog will find <code>seattle</code> first, because it comes first in the database.
<ul>
<li><p>If we want to find all possible solutions, we can ask the interpreter to continue by typing a semicolon:</p>
<pre><code>C = seattle ;
C = rochester ;
No</code></pre></li>
</ul></li>
<li><p>Similarly, given:</p>
<pre><code>rainy(seattle).
rainy(rochester).
cold(rochester).
snowy(X) :- rainy(X), cold(X).</code></pre>
<ul>
<li><p>The query:</p>
<pre><code>?- snowy(C).</code></pre>
<p>Will yield only one solution.</p></li>
</ul></li>
</ul></li>
</ul>
<h4 id="resolution-and-unification">Resolution and Unification</h4>
<ul>
<li>The <em>resolution principle</em>, says that if <span class="math">\(C_1\)</span> and <span class="math">\(C_2\)</span> are Horn clauses and the head of <span class="math">\(C_1\)</span> mathches on of the terms in the body of <span class="math">\(C_2\)</span>, then we can replace the term in <span class="math">\(C_2\)</span> with the body of <span class="math">\(C_1\)</span>.
<ul>
<li><p>Consider the following example:</p>
<pre><code>takes(jane_doe, his201).
takes(jane_doe, cs254).
takes(ajit_chandra, art302).
takes(ajit_chandra, cs254).
classmates(X, Y) :- takes(X, Z), takes(Y, Z).</code></pre>
<ul>
<li><p>If we let <code>X</code> be <code>jane_doe</code> and <code>Z</code> be <code>cs254</code>, we can replace the first term on the right hand side of the last clause with the empty body of the second clause, yielding the new rule:</p>
<pre><code>classmates(jane_doe, Y) :- takes(Y, cs 254).</code></pre>
<p>In other words, <code>Y</code> is a classmate of <code>jane_doe</code> if <code>Y</code> takes <code>cs254</code>.</p></li>
<li>The pattern-matching process ised to associate <code>X</code> with <code>jane_doe</code> and <code>Z</code> with `cs254 is known as <em>unification</em>.</li>
<li><p>Variables that are given values as a result of unification are said to be <em>instantiated</em></p></li>
</ul></li>
</ul></li>
<li>The unification rules for Prolog state:
<ol style="list-style-type: decimal">
<li>A constant unifies only with itself.</li>
<li>Two structures unify if and only if they have the same functor and the same arity, and the corresponding arguments unify recursively.</li>
<li>A variable unifies with anything. If the other thing has a value, then the variable is instantiated. If the other thing is an uninstantiated variable, then the two variables are associated in such a way that if either is given a value later, that value will be shared by both.</li>
</ol></li>
<li><p>Equality in Prolog is defined in terms of &quot;unifiability.&quot;</p>
<pre><code>?- a = a.
Yes             % constant unifies with itself
?- a = b.
No              % but not with another constant
?- foo(a, b) = foo(a, b).
Yes
?- X = a.
X = a ;
No
?- foo(a, b) = foo(X, b).
X = a ;         % arguments must unify
No              % only one possibility</code></pre>
<ul>
<li><p>It is possible for two variable to be unified wihout instantiating them. If we type:</p>
<pre><code>?- A = B.</code></pre>
<p>the interpreter will simply respond</p>
<pre><code>A = B</code></pre>
<ul>
<li><p>If, however, we type</p>
<pre><code>?- A = B, A = a, B = Y.</code></pre>
<p>(unifying <code>A</code> and <code>B</code> before binding <code>a</code> to <code>A</code>) the interpreter will respond</p>
<pre><code>A = a
B = a
Y = a</code></pre></li>
</ul></li>
<li><p>In a similar vein, suppose we are given the following rules:</p>
<pre><code>takes_lab(S) :- takes(S, C), has_lab(C).
has_lab(D) :- meets_in(D, R), is_lab(R).</code></pre>
<ul>
<li>(S takes a lab class if S takes C and C is a lab class. Moreover D is a lab class if D meets in room R and R is a lab.) An attempt to resolve these rules will unify the head of the second with the second term in the body of the first, causing C and D to be unified, even though neither is instantiated.</li>
</ul></li>
</ul></li>
</ul>
<h4 id="lists">Lists</h4>
<ul>
<li>Like equality checking, list manipulation is a sufficiently common operation in Prolog to warrant its own notation.
<ul>
<li>The constuct <code>[a, b, c]</code> is syntatic sugar for the structure <code>.(a, .(b, .(c, [])))</code> where <code>[]</code> is the empty list and <code>.</code> is a built in <code>cons</code>-like predicate.</li>
<li>Prolog adds an extra convinience, however: an optional vertical bar that delimits the &quot;tail&quot; of the list.
<ul>
<li>Using this notiation, <code>[a, b, c]</code> could be expressed as <code>[a, | [b ,c]], [a, b | [c]], or [a, b, c | []]</code>.</li>
</ul></li>
<li><p>This vertical bar-notation is particularly handy when the tail of the list is a vraible:</p>
<pre><code>    member(X, [X | _]).
    member(X, [_ | T]) :- member(X, T).
    sorted([]).         % empty list is sorted
    sorted([_]).        % singleton is sorted
    sorted([A, B | T]) :- A =&lt; B, sorted([B | T]).
       % compound list is sorted if first two elements are in order and
       % remainder of list (after first element) is sorted</code></pre>
<ul>
<li>Here <code>&lt;=</code> is a built-in predicate that operates on numbers.
<ul>
<li>The underscode is a placeholder for a variable that is not needed anywhere else in the clause.</li>
<li>Note that <code>[a, b | c]</code> is the <em>improper</em> list <code>.(a, .(b     c)).</code></li>
<li>The sequence of tokens <code>[a | b, c]</code> is syntactically invalid.</li>
</ul></li>
</ul></li>
</ul></li>
<li>One of the interesting about Prolog resolution is that it does not in general distinguish between &quot;input&quot; and &quot;output&quot; arguments.
<ul>
<li><p>Thus, given:</p>
<pre><code>append([], A, A).
append([H | T], A, [H | L]) :- append(T, A, L).</code></pre>
<p>We can type:</p>
<pre><code>?- append([a, b, c], [d, e], L).
L = [a, b, c, d, e]
?- append(X, [d, e], [a, b, c, d, e]).
X = [a, b, c]
?- append([a, b, c], Y, [a, b, c, d, e]).
Y = [d, e]</code></pre></li>
<li>This example highlight the difference between functions and Prolog predicates.
<ul>
<li>The former have a clear notion of inputs (arguments) and outputs (results).</li>
</ul></li>
</ul></li>
</ul>
<h4 id="arithmetic">Arithmetic</h4>
<ul>
<li>The usual arithmetic operators are available in Prolog, but they play a role of predicates, not of functions.
<ul>
<li>Thus, <code>+(2, 3)</code>, which may also be written <code>2 + 3</code> is a two- argument structure, not a function call.
<ul>
<li><p>It will not unify with <code>5</code>:</p>
<pre><code>?- (2 + 3) = 5
No</code></pre></li>
</ul></li>
</ul></li>
<li><p>To handle arithmetic, Prolog provides a built-in predicate, <code>is</code>, that unifies its first argument with the arithmetic value of its second argument:</p>
<pre><code>?- is(X, 1+2). X=3
?- X is 1+2.
X = 3
?- 1+2 is 4-1.
No
?- X is Y.
ERROR
% infix is also ok
% first argument (1+2) is already instantiated
% second argument (Y) must already be instantiated
?- Y is 1+2, X is Y.
Y=3
X = 3 % Y is instantiated by the time it is needed</code></pre></li>
</ul>
<h4 id="searchexecution-order">Search/Execution Order</h4>
<blockquote>
<p>How does Prolog go about answering a query?</p>
</blockquote>
<ul>
<li>What it needs is a sequence of resolution steps that will build the goal out of clauses in the database, or a proof that no such sequence exists.
<ul>
<li>In the realm of formal logic, one can imagine two principal search strategies:
<ul>
<li>Starting with the existing clauses and work forward, attempting to derive the goal. This strategy is known as <em>forward chaining</em>.</li>
<li>Start with the goal and work backward, attempting to &quot;unresolve&quot; it into a set of preexisting clauses. This strategy is known as <em>backward chaining</em>.</li>
</ul></li>
<li>If the number of existing rules is very large, but the number of facts is small, it is possible for forward chaining to discover a solution more quickly than backward chaining.
<ul>
<li>In most circumstances, however, backward chaining turns out to be more efficient.</li>
<li>Prolog is defined to use backward chaining.</li>
</ul></li>
</ul></li>
<li>Because resolution is associative and commutative, a backward chaining theorem prover can limit its search to sequences of resolutions in which terms on the righ-hand side of a cluase are unified with the heads of other cluases on by one in some particular order.
<ul>
<li>The resulting search can be described in terms of a tree of subgoals.</li>
<li>The Prolog interpreter explores this tree-depth first, from left to right.</li>
<li>It starts at the beginning of the database, searching for a rule <span class="math">\(R\)</span> whose head can be unified with the top-level goal.</li>
<li>It then considers the terms in the body or <span class="math">\(R\)</span> as subgoals, and attempts to satisfy them, recursively, from left to right.</li>
<li>If at any point a subgoal fails, the interpreter returns to the previous subgoal and attempts to satisfy it in a different way.</li>
</ul></li>
</ul>
<div class="figure">
<img src="../img/cs-pl-prolog.png" alt="Backtracking search in Prolog" /><p class="caption">Backtracking search in Prolog</p>
</div>
<ul>
<li>The process of returning to previous goals is known as <em>backtracing</em>
<ul>
<li>Whenever a unification operation is &quot;undone&quot; in order to pursue a different path through the search tree, variables that were given values or associated with one another as a result of that unification are returned to their uninstantiated or unassociated state.</li>
<li>The effect is similar to the breaking of bindings between actual and formal parameters in an imperative programming language, except that Prolog couches the bindings in terms of unification rather than subroutine calls.</li>
</ul></li>
<li>Space management for backtracking search in Prolog usually follows the single-stack implementation of iterators.
<ul>
<li>The interpreter pushes a frame onto its stack every time it begins to pursue a new subgoal <span class="math">\(G\)</span>.</li>
<li>If <span class="math">\(G\)</span> succeeds, control returns to the &quot;caller.&quot;&quot;
<ul>
<li>But <span class="math">\(G\)</span>'s frame remains on the stack.</li>
</ul></li>
<li>Later subgoals will be given space <em>above</em> this dormant frame.
<ul>
<li>If subsequent backtracing causes the interpreter to search for alternative ways of satisfying <span class="math">\(G\)</span>, control will be able to resume where it last left off.</li>
</ul></li>
</ul></li>
<li>The fact that clauses are ordered, and that the interpreter considers them from first to last, means that the results of a Prolog program are determinitic and predictable.
<ul>
<li>In fact, the combinatino of ordering and depth-first search means that the Prolog programmer must oftern consider the order to ensure that recursive programs will terminate.</li>
<li><p>Suppose for example that we have a database describing a directed acyclic graph:</p>
<pre><code>edge(a, b).  edge(b, c).  edge(c, d).
edge(d, e).  edge(b, e).  edge(d, f).
path(X, X).
path(X, Y) :- edge(Z, Y), path(X, Z).</code></pre>
The last two clause tell us how to determine whether there is a path from node <code>X</code> to node <code>Y</code>.
<ul>
<li>If we were to reverse the order of the terms in the right-hand side of the final clause, the the Prolog interpreter would search for node <code>Z</code> that is reachable from <code>X</code> before checking to see whether there is an edge from <code>Z</code> to <code>Y</code>.</li>
<li>The program would still work, but it would not be as efficient.</li>
</ul></li>
</ul></li>
<li><p>Consider what would happen if in addition we were to reverse the order of the last two clauses:</p>
<pre><code>path(X, Y) :- path(X, Z), edge(Z, Y).
path(X, X).</code></pre>
From a logical point of view, our database still defines the same relationships.
<ul>
<li>A Prolog interpreter, however, will no longer be able to find answers.
<ul>
<li>Even a simple query like <code>?- path(a, a)</code> will never terminate.</li>
</ul></li>
<li>The interpreter first unifies <code>path(a, a)</code> with the left-hand side of <code>path(X, Y) :- path(X, Z), edge(Z, Y).</code> It then considers the goals on the right-hand side, the first of which <code>(path(X, Z))</code>, unifies with the left-hand side of the very same rule, leading to an infinite regression.</li>
</ul></li>
</ul>
<h4 id="imperative-control-flow">Imperative Control Flow</h4>
<ul>
<li>We have seen that the ordering of clauses and of terms in Prolog is significant, with ramifications for efficient, termination, and choice among alternatives.
<ul>
<li>In addition to simple ordering, Prolog provides the programmer with several explicit control-flow features
<ul>
<li>The most important of these features is known as <code>cut</code>.</li>
</ul></li>
</ul></li>
<li>The <code>cut</code> is a zero-argument predicate written as an exclamation point
<ul>
<li>As a sungal it alwauys succeeds, but with a crucual side effect: it commit the interpreter to whatever choices have been made since unfifying the parent goal with the left-hand side of the current rule, including the choice of the unification itself.</li>
<li>If a given atom <code>a</code> appears in list <code>L</code> <span class="math">\(n\)</span> times, the goal then the goal <code>?- member(a, L)</code> can succeed <span class="math">\(n\)</span> times.</li>
<li><p>They can lead to wasted computation, particularly from long lists, when <code>member</code> is following by a goal that may fail:</p>
<pre><code>prime_candidate(X) :- member(X, candidates), prime(X).</code></pre>
<p>Suppose that <code>prime(X)</code> is expensive to compute. To determine whether <code>s</code> is a prime candidate, we first check to see whether it is a member of the <code>candidates    list, and then check to see whether it is prime. -   If</code>prime(a)<code>fails, Prolog will backtrack and attempt to      satisfy</code>member(a, candidates)<code>again. If</code>a<code>is in the</code>candidates<code>list more than once, then the goal will suceed     again, leading to the reconsideration of the</code>prime(a)<code>subgoal,     even though it is doomed to fail. *We can save substantial     time by cutting off all further searches for</code>a` after the first is found:</p>
<pre><code>    member(X, [X | _]) :- !.
    member(X, [_ | T]) :- member(X, T).

The cut on the right hand side of the first rule says that if
`X` is the head of `L`, we should not attempt to unify
`member(X, L)` with the left hand side of the second rule,
the cut commits us to the first rule.</code></pre></li>
</ul></li>
<li><p>An alternative way to ensure that <code>member(X, L)</code> succeeds no more than once is ember a use of <code>\+</code> in the seoncd cluase:</p>
<pre><code>member(X, [X | _]).
member(X, [H | T]) :- X \= H, member(X, T).</code></pre>
<p>Here <code>X \= H</code> means <code>X</code> and <code>H</code> will not unify.</p></li>
</ul>
<h3 id="scheme-macros-via-will-donnelly">Scheme Macros <small>via <a href="http://www.willdonnelly.net/blog/scheme-syntax-rules/">Will Donnelly</a></small></h3>
<ul>
<li><p>You use define-syntax to create a top level binding, and let-syntax bears the same relationship to define-syntax as you’d expect.</p>
<pre><code>;; define-syntax is used to create
;;  a top-level binding of a macro
(define-syntax macro
  &lt;syntax transformer&gt;)</code></pre></li>
<li><p>Lets say we want to define a <code>while</code> loop to work like this:</p>
<pre><code>;; A simple while loop
(define x 0)
    (while (&lt; x 5)
    (set! x (+ x 1))
    (print x))</code></pre></li>
<li><p>To do this, we need to use a <strong>syntax transformer</strong>.</p>
<pre><code>(define-syntax while
    (syntax-rules (&lt;keywords&gt;)
    ((&lt;pattern&gt;) &lt;template&gt;)
    ...
    ((&lt;pattern&gt;) &lt;template&gt;)))</code></pre></li>
<li><p>This is how to code a <code>while</code> loop in Scheme:</p>
<pre><code>(let loop ()
    (if condition
        (begin
            body ...
            (loop))
        #f)
    )</code></pre></li>
<li><p>This code above is what is to be placed in <code>&lt;template&gt;</code>.</p>
<pre><code>(define-syntax while
  (syntax-rules ()
    ((while condition body ...)
     (let loop ()
       (if condition
           (begin
             body ...
             (loop))
           #f)))))</code></pre></li>
</ul>
<h3 id="prolog-basic-operation-of-prolog">Prolog <small>Basic operation of Prolog</small></h3>
<dl>
<dt>Unification</dt>
<dd><p>An algorithmic process of solving equations between symbolic expressions.</p>
</dd>
<dd><p>Prolog unification matches two Prolog terms T1 and T2 by finding a substitution of variables mappich M such that if M is applied T1 and M is applied to T2 and the results are equal.</p>
<p>For example, Prolog uses unification in order to satisfy equations ...</p>
<pre><code>?- p(X, f(Y), a) = p(a, f(a), Y).
X = a  Y = a

?- p(X, f(Y), a) = p(a, f(b), Y).
No</code></pre>
<p>In the first case the successful substitution is <code>{X/a, Y/b}</code>, and for the second example there is no substitution that would result in equal terms.</p>
</dd>
<dt>Backward chaining</dt>
<dd><p>An inference method that can be described as working backwards from the goal(s). It is used in automated theorem provers, proof assistants, and other AI application, but it has also been observed in primates.</p>
</dd>
<dt>Backtracking</dt>
<dd><p>Suppose that we have the following database:</p>
<pre><code>eats(fred, pears).
eats(fred, t_bone_steak).
eats(fred, apples).</code></pre>
<p>So far we have only been able to ask if Fred eats specific thing. Suppose that I wish to instead to answer the question, &quot;What are all the things that Fred eats?&quot; To answer this I can use variables again. Thus, I can type in the query.</p>
<pre><code>?- eats(fred, FootItem).</code></pre>
<p>As we have seen earlier, Prolog will answer with</p>
<pre><code>FoodItem = pears</code></pre>
<p>This is because it has found the first clause in the database. If you keep asking, Prolog will respond <code>t_bone_steak</code> then <code>apples</code> then <code>no</code>.</p>
</dd>
</dl>
<h3 id="logical-meaning-of-prolog">Logical meaning of Prolog</h3>
<blockquote>
<p>The token <code>:-</code> is the implication symbol.</p>
<p>The comma indicates &quot;logical and.&quot;</p>
<p>Variables that appear in the head of a Horn clause are universally quantified.</p>
</blockquote>
<h3 id="prolog-programming">Prolog programming</h3>
<dl>
<dt>Unification (on lists)</dt>
<dd><p>Consider the rule:</p>
<pre><code>append([A|B],Y,[A|Z]):- ...</code></pre>
<p>And the query:</p>
<pre><code>?- append([a,b],[c],W)</code></pre>
<p>Unify?</p>
<pre><code>A=a, B=[b], Y=[c], W=[a | Z]</code></pre>
</dd>
<dt>Cut</dt>
<dd><p>The cut, in Prolog, is a goal, written as !, which always succeeds, but cannot be backtracked past. It is best used to prevent unwanted backtracking, for example, to prevent extra solutions being found by Prolog and avoid additional computations that are not desired or required in a program.</p>
<p>The cut should be used sparingly. There is a temptation to insert cuts experimentally into code that is not working correctly. If a test is unnecessary because a cut has guaranteed that it is true, it is good practice to say so in a comment at the appropriate place.</p>
</dd>
<dd><dl>
<dt>Green cut</dt>
<dd><p>A use of a <em>cut</em> which only improves efficiency is referred to as a <em>green cut</em>. For example:</p>
<pre><code>gamble(X) :- gotmoney(X),!.
gamble(X) :- gotcredit(X), \+ gotmoney(X).</code></pre>
<p>This is called a green cut operator. The <code>!</code> simply tells the interpreter to stop looking for alternatives. But you'll notice that if <code>gotmoney(X)</code> fails it will check the second rule. Checking for <code>gotmoney(X)</code> in the second rule seems useless since you already know that if Prolog is there then <code>gotmoney(X)</code> failed before, otherwise the second rule wouldn't be evaluated in the first place. However, by explicitly writing <code>\+ gotmoney(X)</code>, you guarantee that the second rule will always work, even if the first one is removed by accident or changed.</p>
</dd>
<dt>Red Cut</dt>
<dd><p>A <em>cut</em> that isn't a <em>green cut</em> is referred as a <em>red cut</em>, for example:</p>
<pre><code>gamble(X) :- gotmoney(X),!.
gamble(X) :- gotcredit(X).</code></pre>
<p>You depend on the proper placement of the cut operator and the order of the rules to determine their logical meaning. If for any reason the first rule is removed (e.g. by a cut-and-paste accident), the second rule will be broken, i.e., it will not guarantee the rule <code>\+ gotmoney(X)</code>.</p>
</dd>
</dl>
</dd>
<dd><p>A cut, simply stated, commits Prolog to the instantiations made prior to it.</p>
</dd>
<dt>Numbers, <code>is</code></dt>
<dd><p>The is built-in predicate is used in Prolog to force the evaluation of arithmetic expressions. If you just write something like <code>X = 2 + 4</code>, the result is to bind <code>X</code> to the unevaluated term <code>2 + 4</code>, not to <code>6</code>.</p>
<pre><code>?- X = 2 + 4.
X = 2+4</code></pre>
<p>If instead you write X is 2 + 4, Prolog arranges for the second argument, the arithmetic expression 2 + 4, to be evaluated (giving the result 6) before binding the result to X.</p>
<pre><code>?- X is 2 + 4.
X = 6</code></pre>
<p>If you want to check some arithmetic with a function or something or another, it would look like this:</p>
<pre><code>0 is N mod 2</code></pre>
</dd>
<dt>Trees</dt>
<dd><ul>
<li>Really have built an evaluation tree for the query <code>member(X,[a,b,c])</code>.</li>
<li>Search trees provide a formalism to consider all possible computation paths.</li>
<li>Leaves are success nodes or failures where computation can proceed no further.</li>
<li>By convention, to model Prolog, leftmost subgoal is tried first.</li>
</ul>
</dd>
<dt>Graphs</dt>
<dd><p>A list of nodes.</p>
<dl>
<dt>Node</dt>
<dd><p><code>node(Name, Color, Nbrnames).</code></p>
<p><code>node_structure(Name, Graph, node).</code></p>
<ol style="list-style-type: decimal">
<li><p>How to grab all <em>names</em> of a node? <code>all_names(+Graph, -Names) =&gt;</code></p>
<pre><code>all_names([], []).
all_name([H | T], Namelist) :- 
    node_structure(Name, [H | T], H),
    all_names(T, Tnamelist),           ; until the end level of recursion
    append([Name], Tnamelist, Namelist).</code></pre></li>
<li><p>How to grab the <em>neighbor</em> of a node? <code>node_backlinks_valid(+Name, +Nbrnames, +Graph) =&gt;</code></p>
<pre><code>node_backlinks_valid(_, [], _).
node_backlinks_valid(Name, [H | T], Graph) :-
    node_structure(H, Graph, node(H, _, NbrNames)),
    member(Name, Nbrnames),
    node_backlinks_valid(Name, T, Graph).</code></pre></li>
<li><p>How to grab the <em>color</em> of a node? <code>colors_of(+Names, +Graph, -Colors) =&gt;</code></p>
<pre><code>colors_of([], _, []).
colors_of([H | T], Graph, Colorslist) :-
    node_structure(H, Graph, node(H, Color, _)),
    colors_of(T, Graph, Tcolorlist),
    append([Color], Tcolorlist, Colorlist).</code></pre></li>
</ol>
</dd>
</dl>
</dd>
</dl>
<h3 id="practice-exam-2">Practice Exam 2</h3>
<ol style="list-style-type: decimal">
<li><p>Finish the definition below of the scheme macro and-not, so that (and-not x y) is the equivalent of (and x (not y)). Note that <code>and-not</code> should have the same kind of “short cut” behavior as <code>and</code> and <code>or</code> have, and as <code>x &amp;&amp; y</code> has in Java: if <code>x</code> is false, it should not evaluate <code>y</code>, but should just return false. (This is why <code>and-not</code> needs to be a macro.)</p>
<pre><code>(define-syntax and-not
    (syntax-rules()
        ((_ x y)
            (and x (not y) ; &lt;- this is the answer fill-in
           ; the exam will provide the name of the macro
        ))
    )</code></pre></li>
<li>Fill in the following prolog predicates.
<ol style="list-style-type: decimal">
<li><p><code>inOrder(List)</code>. Assume <code>List</code> is a list of numbers; <code>inOrder(List)</code> is true if and only if the numbers in <code>List</code> are in increasing order. If <code>List</code> has <code>0</code> or <code>1</code> element it is in order.</p>
<pre><code>inOrder([]).  ; if it has no elements
inOrder([_]). ; if it has one element, any element
inOrder([ N1, N2 | T]) :- N1 &lt;= N2, inOrder([N2 | T]).</code></pre></li>
<li><p><code>suffix(L1, L2)</code>. Assumes <code>L1</code> and <code>L2</code> are lists. It is true if <code>L2</code> is a tail of <code>L1</code>. E.g., <code>suffix([x, a, b], [a, b])</code> is true, as is <code>suffix([x, y, a, b], [a, b])</code>, <code>suffix([x, y, z, a, b], [a, b])</code>, and so on.</p>
<pre><code>suffix([H | T], T).                  ; general pattern
suffix([H, T], L2) :- suffix(T, L2). ; split first list,
                                     ; implies T is equal to L2</code></pre></li>
</ol></li>
<li><p>For each of the following pairs of fact and goal, say whether they will unify, and if so with which bindings</p>
<table>
<thead>
<tr class="header">
<th align="left">Fact</th>
<th align="left">Goal</th>
<th align="left">Unify</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>foo(Bar, baz).</code></td>
<td align="left"><code>foo(baz, Bletch).</code></td>
<td align="left"><code>Bar = baz</code>, <code>Bletch = baz</code></td>
</tr>
<tr class="even">
<td align="left"><code>foo(a, b)</code></td>
<td align="left"><code>fie(X,Y)</code></td>
<td align="left">Will not unify</td>
</tr>
<tr class="odd">
<td align="left"><code>foo(a, fie(Y, X))</code></td>
<td align="left"><code>foo(X, fie(a,a))</code></td>
<td align="left"><code>X = a, X = Y = a</code>[^1]</td>
</tr>
</tbody>
</table></li>
<li><p>The predicate <code>odd(All, Odds)</code> is true if <code>Odds</code> and <code>All</code> are lists and <code>Odds</code> contains the 1st, 3rd, 5th, etc, elements of <code>All</code> (in that order), Hint: <code>[a, b | c]</code> is a list whose first two elements are <code>a</code> and <code>b</code>, and whose tail after <code>b</code> (i.e. the <code>cddr</code>) is c. <code>odds([],[])</code> is also true. Define <code>odds</code>:</p>
<pre><code>odds([],[]).                             ; trivially true base case
odds([X], [X]).                          ; equality clause
odds([A, B | C], [H | T]) :- odds(C, T). ; ignores evens in first list</code></pre></li>
<li><p>What is the translation into predicate calculus of the prolog rule: <code>cousin(X,Y):- grandparent(X, G), grandparent(Y, G), nonsibling(X, Y)</code>.</p>
<p>For all <code>X</code> and <code>Y</code>, if <code>X</code> and <code>Y</code> are cousins, then there exists <code>G</code> is a grandparent of <code>X</code>, <code>G</code> is a grandparent for <code>Y</code>, and <code>X</code> and <code>Y</code> are not siblings.</p>
<p><span class="math">\[ \forall x y (C(x, y) \to \exists g (G(x, g) \land G(y, g) \land \lnot S(x, y)))\]</span></p></li>
<li><p>What will this print for the query <code>foo(X, Y).</code>? (The predicate write simply prints its argument.</p>
<pre><code>foo(1, 2) :- write(12), 1 &lt; 1.
foo(X, 2) :- fie(X), write(x2), 2&lt;1. 
foo(1, Y) :- write(y1).

fie(a) :- write(a). 
fie(b) :- write(b).</code></pre></li>
<li><p>Define the predicate <code>insertInOrder(Lst, Num, Res)</code>, where <code>Lst</code> is a list of numbers in ascending order and <code>Res</code> is the result of inserting <code>Num</code> in its correct place in <code>Lst</code>. E.G., <code>insertInOrder([1, 3, 6, 9], 5, [1, 3, 5, 6, 9])</code> is <code>true</code>.</p>
<pre><code>insertInOrder([], N, [N | T]).
insertInOrder([H | T], N, [H, N | T]).
insertInOrder([H1 | T1], N, [H2 | T2]) :- H1 &lt;= N, 
                                          insertInOrder(T1, N, T2).</code></pre></li>
<li><p>Given the following code, what will the query <code>vacation(A)</code> print? Hint: If the variable <code>V</code> has value <code>a</code>, <code>write([fun, V])</code> prints <code>[fun, a]</code>. fail is a predicate that always fails.</p>
<pre><code>vacation(Activity) :- fun(Activity), write([fun, Activity]),
                       cheap(Activity), write([cheap, Activity]), !, fail.       
fun(Activity):- speed(Activity, S), S &gt; 50. 
fun(Activity):- outdoors(Activity). 
speed(skiing, 75).
outdoors(skiing).
outdoors(hiking). 
cheap(hiking).

?- vacation(A)
[fun,skiing][fun,skiing][fun,hiking][cheap,hiking] 
false</code></pre></li>
</ol>
<h2 id="december-15th-2013-final-exam-study-guide">December 15th, 2013 <small>Final Exam Study Guide</small></h2>
<h3 id="meta-interpreters">Meta interpreters</h3>
<dl>
<dt>Meta-interpreter</dt>
<dd><p>A <em>meta</em> interpreter is an interpreter for a language written in the language it interprets.</p>
<blockquote>
<p>Why do such a thing?</p>
</blockquote>
<ul>
<li>The easiest language to write a Prolog interpreter is Prolog.</li>
<li>Once you have an interpreter, you can modify it.</li>
</ul>
</dd>
</dl>
<h3 id="types">Types</h3>
<h4 id="what-is-a-type">What is a type?</h4>
<ul>
<li>A set of values and the valid operations on those values.
<ul>
<li><p>Integers</p>
<pre><code>+ - * div &lt; &lt;= = &gt;= &gt;</code></pre></li>
<li><p>Arrays</p>
<pre><code>lookUp(&lt;array&gt;, &lt;index&gt;)
assign(&lt;array&gt;, &lt;index&gt;, &lt;value&gt;)
initialize(&lt;array&gt;)
setBound(&lt;array&gt;)</code></pre></li>
<li>User-defined types:
<ul>
<li>Structs</li>
<li>Classes</li>
</ul></li>
</ul></li>
<li>Program semantics embedded in types used
<ul>
<li>Additional correctness check provided beyond valid syntax.</li>
</ul></li>
</ul>
<h5 id="constructed-types">Constructed types</h5>
<ul>
<li>Constructive point-of-view
<ul>
<li>Primitive types, <code>int</code>, <code>char</code>, <code>bool</code>, <code>enum</code></li>
<li><p>Composition/constructive types:</p>
<table>
<thead>
<tr class="header">
<th align="left">Structure</th>
<th align="left">Function</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">reference</td>
<td align="left">pointerTo(int)</td>
</tr>
<tr class="even">
<td align="left">array</td>
<td align="left">arrayOf(char)</td>
</tr>
<tr class="odd">
<td align="left">record</td>
<td align="left">record(age:int, name:string)</td>
</tr>
<tr class="even">
<td align="left">subrange</td>
<td align="left">int[1..20]</td>
</tr>
<tr class="odd">
<td align="left">union</td>
<td align="left">union(int, pointerTo(char))</td>
</tr>
<tr class="even">
<td align="left">list</td>
<td align="left">list(...)</td>
</tr>
<tr class="odd">
<td align="left">set</td>
<td align="left">setOf(color)</td>
</tr>
<tr class="even">
<td align="left">function</td>
<td align="left">float, int</td>
</tr>
</tbody>
</table></li>
</ul></li>
</ul>
<h5 id="varieties">Varieties</h5>
<ul>
<li>Implicit
<ul>
<li>Values are typed, but variables aren't</li>
<li>Prolog, Scheme, Lisp, Smalltalk, Python</li>
</ul></li>
<li>Explicit
<ul>
<li>Declarations bind types to variables at compile time</li>
<li>Pascal, Algol68, C, C++, Java</li>
</ul></li>
<li>Mixture
<ul>
<li>Implicit by default but allows explicit declarations</li>
<li>Haskell, ML, Common Lisp</li>
<li>Trust declarations result in speed</li>
<li>Test declarations result in correctness</li>
</ul></li>
</ul>
<h5 id="systems">Systems</h5>
<ul>
<li>Rules for constructing types</li>
<li>Rules for determining/inferring the type of expressions</li>
<li>Rules for compatibility
<ul>
<li>In what contexts can values of a type be used?</li>
</ul></li>
<li>Rules for type equivalence or type conversion
<ul>
<li>Determining that an expression can be used in some context</li>
</ul></li>
</ul>
<h5 id="expressions">Expressions</h5>
<ul>
<li>If <span class="math">\(f\)</span> has type <span class="math">\(S\)</span> and <span class="math">\(T\)</span>, <span class="math">\(x\)</span> has type <span class="math">\(S\)</span>, then <span class="math">\(f(x)\)</span> has type <span class="math">\(T\)</span>
<ul>
<li>Type of <code>3 div 2</code> is <code>int</code></li>
<li>Type of <code>round(3.5)</code> is <code>int</code></li>
</ul></li>
<li><p><em>Type error</em> is using wrongly typed operands in an operation</p>
<pre><code>round(&quot;Nancy&quot;)
3.5 div 2
&quot;abc&quot; + 3</code></pre></li>
</ul>
<h4 id="type-checking">Type checking</h4>
<ul>
<li><em>Goal</em>: To find out as early as possible, if each procedure and operator is supplied with the correct type of arguments.
<ul>
<li>Type error: when a type is used improperly in a context.</li>
<li>Type checking performed to prevent type errors</li>
</ul></li>
<li>Modern PLs often designed to do type checking during compilation.</li>
</ul>
<h5 id="varieties-of-type-checking">Varieties of type checking</h5>
<ul>
<li>Compile-time (static)
<ul>
<li>At compile, uses declaration information or can infer types from variable uses.</li>
</ul></li>
<li>Run-time (dynamic)
<ul>
<li>During executing, checks type of a value before doing operations on it.</li>
<li>Uses type tags to record types of values.</li>
</ul></li>
<li>Combined (compile and run time)</li>
</ul>
<h5 id="type-safety">Type safety</h5>
<ul>
<li>A <em>type safe</em> program executes on all inputs without type errors.
<ul>
<li>Goal of type checking is to ensure type safety.</li>
<li><p>Type safe does not mean without error.</p>
<pre><code>read n;
if n&gt;0 then { y :=&quot;ab&quot;;
                if n&lt;0 then x := y - 5; }</code></pre>
<ul>
<li>Not that the assignment to <code>x</code> is never executed so program is type safe but contains an error.</li>
</ul></li>
</ul></li>
</ul>
<h5 id="strong-typing">Strong typing</h5>
<ul>
<li>Strongly typed PL by definition, PL requires all programs to be type checkable.</li>
<li>Statically strongly typed PL means that the compiler allows only programs that can be type checked fully at compile time.
<ul>
<li>Algol68</li>
<li>ML</li>
</ul></li>
<li>Dynamically strongly typed PL means that operations include code to check runtime types of operands, if type cannot be determined compile-time.
<ul>
<li>Pascal</li>
<li>Java</li>
</ul></li>
</ul>
<h5 id="hierarchy-of-types">Hierarchy of types</h5>
<div class="figure">
<img src="../img/cs-pl-types.png" alt="Hierarchy of programs" /><p class="caption">Hierarchy of programs</p>
</div>
<table>
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Static checking</th>
<th align="left">Dynamic checking</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><strong>Implicit types</strong></td>
<td align="left">ML</td>
<td align="left">Scheme</td>
</tr>
<tr class="even">
<td align="left"><strong>Explicit types</strong></td>
<td align="left">Algol68</td>
<td align="left">C, Pascal</td>
</tr>
</tbody>
</table>
<h5 id="difficulties-in-static-type-checking">Difficulties in Static Type Checking</h5>
<ul>
<li>If validity of expression depends not only on the types of the operands but on their values, static type checking cannot be accomplished.
<ul>
<li>Taking successors of enumeration types</li>
<li>Using unions without type test guard</li>
<li>Converting ranges into subranges</li>
<li>Reading values from input</li>
<li>Dereferencing <code>void *</code> pointers</li>
</ul></li>
</ul>
<h4 id="type-conversion">Type conversion</h4>
<h5 id="implicit-conversion">Implicit conversion</h5>
<ul>
<li>Also known as <em>coercion</em></li>
<li><p>In C, mixed mode numerical operations</p>
<pre><code>double d, e; e = d + 2 // 2 coerced to 2.0</code></pre></li>
<li>Usually can use widening or conversion without loss of precision</li>
<li>Cannot coerce user-defined types or structures</li>
<li><p>But you can do <code>Shape s = new Circle();</code></p></li>
</ul>
<h5 id="explicit-conversion">Explicit conversion</h5>
<ul>
<li><p>In Pascal, can explicitly convert types which may lose precision, also known as narrowing.</p>
<pre><code>round(s); // int by rounding
trunc(s); // int by truncating</code></pre></li>
<li><p>In C, casting sometimes is explicit conversion</p>
<pre><code>dqstr((double) n); // where n is declared to be an int
free list * s; ... (char *) s; // forces s to be considered
// as pointing to a char for purposes of pointer arithmetic</code></pre></li>
</ul>
<h5 id="overloading-operators">Overloading operators</h5>
<ul>
<li>Primitive type of <em>polymorphism</em>
<ul>
<li>When an operator allows operands of more than one type, in different contexts</li>
</ul></li>
<li>Examples
<ul>
<li>Integer addition: 1 + 2 versus real addition: 1.0 + 2.0</li>
<li>Addition: 2 + 3 is 5, versus concatenation: &quot;abc&quot; + &quot;def&quot; is &quot;abcdef&quot;</li>
<li>Comparision operator used for two different types: 2 == 3 verssus &quot;abc&quot; == &quot;def&quot; in Python.</li>
</ul></li>
</ul>
<h5 id="primitive-types">Primitive Types</h5>
<ul>
<li>Issues
<ul>
<li>Type checking</li>
<li>Representation in the machine</li>
</ul></li>
<li>Boolean
<ul>
<li>Use of integer 0 / non-0 versus true/false</li>
</ul></li>
<li>Char versus string</li>
<li>Integer
<ul>
<li>Length fixed by standards or implementation (portability issues)</li>
<li>Multiplie lengths (C: short, int, long)</li>
<li>Signs</li>
</ul></li>
<li>Float/real
<ul>
<li>Should value comparisons be allowed?</li>
</ul></li>
</ul>
<h4 id="arrays">Arrays</h4>
<h5 id="definition">Definition</h5>
<ul>
<li>Indexed collection of values, often homogenous</li>
<li>Access to individual elements through subscript</li>
<li>Choices made by PL design:
<ul>
<li>Subscript syntax</li>
<li>Subscript type, element type</li>
<li>When to set bounds, compile time or run time?</li>
<li>Are bounds changeable</li>
<li>How to initialize?</li>
<li>What operations allowed on whole arrays?</li>
</ul></li>
</ul>
<h5 id="array-type">Array type</h5>
<ul>
<li>What is part of the array type?
<ul>
<li>Size?</li>
<li>Bounds?
<ul>
<li>Pascal: bounds are part of the type</li>
<li>C, Algol68: bounds are not part of type</li>
<li>Must be fixed at compile-time in Pascal but can be set at runtime in C and Fortran</li>
</ul></li>
<li>Dimension? always part of the type</li>
</ul></li>
<li>Choice has ramifications on kind of type-checking needed</li>
</ul>
<h5 id="choices-for-arrays">Choices for Arrays</h5>
<ul>
<li>Global lifetime, static shape (in static memory)</li>
<li>Local lifetime
<ul>
<li>Static shape</li>
<li>Shape bound at elaboration time when control enters a scope
<ul>
<li>Ada, Fortran, allow definition of array bounds when function is elaborated</li>
</ul></li>
</ul></li>
<li>Arrays as objects (Java)
<ul>
<li><p>Shape bound at elaboration time (kept in heap)</p>
<pre><code>int[] a; a = new int[size];</code></pre></li>
</ul></li>
</ul>
<h5 id="implementation">Implementation</h5>
<ul>
<li>For fixed length array, symbol table keeps track of name, element type, bounds etc during compilation, can allocate in static storage or on frame of declaring method.</li>
<li>For arrays whose length is not knowable at compile-time, we use a dope vector, a designator of fixed size on the stack frame, and then allocate space for the array data separately.</li>
<li>Dope vector contains
<ul>
<li>Name, type of subscript, bounds, type of elements, number of bytes in each element, point to first storage location of array</li>
<li>Allows calculation of actual address of an array element from these values.</li>
</ul></li>
</ul>
<h5 id="universal-indirection">Universal Indirection</h5>
<ul>
<li><p>C++:</p>
<pre><code>struct point{int x, int y} center;</code></pre></li>
<li><p>Java:</p>
<pre><code>Point center = new Point(0, 0);</code></pre></li>
<li><p>Extra indirection allows</p>
<pre><code>Shape s = new Square (2);</code></pre></li>
<li>But costs:
<ul>
<li>Extra cost of heap allocation</li>
<li>Boxing and unboxing</li>
</ul></li>
<li><p>This is why ints, floats, chars, are not objects in Java.</p></li>
</ul>
<h5 id="strong-typing-1">Strong typing</h5>
<ul>
<li>Type errors caught as type errors
<ul>
<li>Rather than &quot;bus error&quot; or just garbage out</li>
</ul></li>
<li>Prevents certain &quot;efficient&quot; techniques
<ul>
<li>Union record types</li>
<li>Casting void* pointers</li>
</ul></li>
<li>Efficient in what?</li>
<li>Modern languages avoid need for unsafe operations
<ul>
<li>Checking casting of references</li>
</ul></li>
</ul>
<h5 id="explicit-types">Explicit types</h5>
<ul>
<li>Allow many type errors to be caught by compiler</li>
<li>Require programmer to enter types
<ul>
<li>But if problem well-understood and large, probably should have pre-planned this information anyway.</li>
</ul></li>
<li>Prevent some convenient program methods
<ul>
<li>Lists of non-homogenous types of elements</li>
<li>Modern languages reduce need for these methods</li>
</ul></li>
</ul>
<h4 id="type-rules">Type rules</h4>
<pre><code>E e1: integer E e2:integer
--------------------------
E (e1 + e2):integer</code></pre>
<ul>
<li>If both operands of <code>+</code> are integers, the result is an integer</li>
<li>E is a <em>type-environment</em> that maps constant and variables to their types.</li>
</ul>
<h3 id="scripting-and-dynamic-langues">Scripting and Dynamic Langues</h3>
<ul>
<li>Examples of scripting languages
<ul>
<li>Python, Ruby, Perl</li>
</ul></li>
<li>Goals
<ul>
<li>Rapid prototyping</li>
<li>Easy implementation of simple programs</li>
<li>Pasting together existing programs</li>
</ul></li>
</ul>
<h4 id="history">History</h4>
<ul>
<li>Unix approach: combine simple programs</li>
<li><p>EG: To find largest files</p>
<pre><code>du -a /Applications/Racket* | sort -nr -k1</code></pre></li>
<li>Need automation, shell scripts
<ul>
<li>Eg post-slides-314</li>
</ul></li>
<li>Note interface on a pipe is a stream of chars
<ul>
<li>Normally a stream of lines, sort sorts lines</li>
</ul></li>
<li><p>Data as stream of lines, line as array of fields, awk</p></li>
</ul>
<h4 id="awk">Awk</h4>
<ul>
<li><p>Awk program: sequence of statements</p>
<pre><code>Line-selection {action}</code></pre></li>
<li>Line selector: one or two regular expressions or boolean expr or BEGIN or END</li>
<li>Action: assign, functions, print, if, ...</li>
<li>Variables, arrays with string indices</li>
<li><p>For each line of input</p>
<pre><code>for each line of the program
    if selector then do action</code></pre></li>
</ul>
<h5 id="examples">Examples</h5>
<ul>
<li><p>Average 2nd field when it exists</p>
<pre><code>NF &gt;= 2 {total += $2; ct+=1}
END (if (ct&gt;0) print total/ct; else print nothing to average</code></pre></li>
<li><p>Count of each word</p>
<pre><code>NR &gt; 0 {ct[$1]++}
END {for (a in ct) print a, ct[a]}</code></pre></li>
</ul>
<h4 id="perl">Perl</h4>
<ul>
<li>Awk not enough power for anything for anything but smallest programs
<ul>
<li>Weak handling of user-defined functions and local variables</li>
</ul></li>
<li>Perl: general programming languages
<ul>
<li>But with syntax for &quot;do this regexp munge to each line&quot;</li>
</ul></li>
<li>Perl &quot;just grew&quot; from a personal language
<ul>
<li>Lots of special global variables, <code>@ARGS, @_</code></li>
<li>Not <code>@</code> sign: array. Also <code>$var</code> scalar value.</li>
<li>Influenced by shell command langage.</li>
</ul></li>
</ul>
<h4 id="dynamic-languages">Dynamic Languages</h4>
<ul>
<li>E.g. scheme</li>
<li>Blur runtime / compile time</li>
<li>Interactive read-eval-print loop</li>
<li>Data has a type, variable does not</li>
<li>Built in syntax for I/O of lists, arrays, etc.</li>
<li>Good for rapid prototyping</li>
<li>Provides manual access to a body of code, R, Matlab</li>
</ul>
<h4 id="newer-scripting-languages">Newer Scripting Languages</h4>
<ul>
<li>Python, Ruby
<ul>
<li>Web scripting languages (Javascript, PHP, ASP) are something different</li>
</ul></li>
<li>Dynamic</li>
<li>Scripting
<ul>
<li>Facilities to handle processes, files</li>
<li>Facilities to handle file as list of lines</li>
<li>Regular expressions</li>
<li>Embeddable, extensible</li>
<li>High-level data structures</li>
</ul></li>
<li>Extensive libraries
<ul>
<li>Standard central repository on the web</li>
</ul></li>
<li>Still started as personal languages but by people with exposure to more modern languages.</li>
</ul>
<h3 id="python">Python</h3>
<ul>
<li><p>Indentation instead of <code>{}</code></p>
<pre><code>while j &lt; 5:
    k = 0
    while k &lt; j:
        print k + j, &#39; &#39;,

    print &#39;\n&#39;

print &#39;Done&#39;</code></pre></li>
</ul>
<h4 id="data-sequence-types">Data Sequence Types</h4>
<ul>
<li>Sequence types: strings, lists, tuples
<ul>
<li>Indices start 0, like Java</li>
<li><p>Slice: like Java substring</p>
<pre><code>a = &#39;help&#39;
a[0:2] is &#39;he&#39;
a[2:] is &#39;lp&#39;, so is a[2:4] and a[2:20]
len( a[2:4] ) is 2</code></pre></li>
</ul></li>
<li><p>Iteration over sequences</p>
<pre><code>for b in a:
    print b</code></pre></li>
</ul>
<h4 id="lists-1">Lists</h4>
<ul>
<li><p>List</p>
<pre><code>[2, 3.1, &#39;foo&#39;]</code></pre></li>
<li><p>Can slice</p>
<pre><code>a = [3, 4.5, &#39;foo&#39;]
a[2:3] is [&#39;foo&#39;]
a[2] is &#39;foo&#39;</code></pre></li>
<li><p>Can assign to slice</p></li>
</ul>
<h4 id="other-data">Other data</h4>
<ul>
<li>Tuple
<ul>
<li>Like list but cannot be changed</li>
<li>Use paren(4, 7)</li>
</ul></li>
<li>Set
<ul>
<li><p>No duplicates, no order</p>
<pre><code>set([1, 4, 2, 1]) == set([2, 1, 4]) == true</code></pre></li>
</ul></li>
<li>Dictionary
<ul>
<li><p>A hash table, a set of key value pairs</p>
<pre><code>a = {&#39;horse&#39;:4, &#39;fish&#39;:0}</code></pre></li>
<li><code>a['fish']</code> returns 0</li>
<li><p>Key must be immutable</p></li>
</ul></li>
</ul>
<h4 id="tuple-assignment">Tuple Assignment</h4>
<ul>
<li><code>(x, y) = (0, 1)</code>
<ul>
<li>Sets <code>x</code> to <code>o</code> and <code>y</code> to <code>1</code></li>
</ul></li>
<li><code>(x, y) = (y, x)</code>
<ul>
<li>Swaps <code>x</code> and <code>y</code> valyes</li>
<li>Evaluate both <code>y</code> and <code>x</code> first, then do assignment</li>
</ul></li>
</ul>
<h4 id="conditionals">Conditionals</h4>
<pre><code>if a&lt;0:
    print &#39;negative&#39;
elif a==0:
    print &#39;zero&#39;
else:
    print &#39;positive&#39;</code></pre>
<h4 id="loops">Loops</h4>
<ul>
<li><p>while a =1</p>
<pre><code>while a&lt;=n: 
    print a</code></pre></li>
<li><p>for</p>
<pre><code>for a in range(1, n, 2):</code></pre></li>
<li><p>range</p>
<pre><code>range(start, end, step)</code></pre></li>
</ul>
<h4 id="tuple-assignment-1">Tuple Assignment</h4>
<ul>
<li><p>Tuple assignment works in both function calls and for loops</p>
<pre><code>def foo( (x,y), z) 
    print x
    print z 

a = (1, 2)
foo(a, 3)

$ 1 
$ 3</code></pre></li>
</ul>
<h4 id="break-and-else-for-loops">Break and Else <small>for loops</small></h4>
<pre><code>for n in range(len(lst)): 
    if lst[n]==0:
        print n
        break
    else:
        print &#39;not &#39; + (&#39;%i&#39; % n)

else:
    print &#39;none&#39; 

print &#39;done&#39;</code></pre>
<h4 id="filer-map-and-reduce">Filer, Map, and Reduce</h4>
<ul>
<li><p>filter(fn, list)</p>
<pre><code>filter(lambda n: n+1 !=5, [3, 4, 6])
returns [3, 6]</code></pre></li>
<li><p>map(fn, list)</p>
<pre><code>map(lambda n: n+1, [3, 4, 6])
returns [4, 5, 7]</code></pre></li>
<li><p>reduce(fn, list)</p>
<pre><code>reduce(lambda x, y: x+y, [3, 2, 1])
returns 6</code></pre></li>
</ul>
<h4 id="list-comprehensions">List Comprehensions</h4>
<ul>
<li>[ <expression> for <var> in <list> ]</li>
<li>[n*n for n in [3, 4, 6] if n+1 != 5]
<ul>
<li>returns [9, 36]</li>
</ul></li>
<li>Like a combination of map and filter, may be more readable</li>
<li>Multiple fors: leftmost = outer loop
<ul>
<li>[(x,y) for x in [2,3,4] if x&gt;2 for y in [5, 6] if x*y!=20]</li>
<li>returns [(3, 5), (3, 6), (4, 6)]</li>
</ul></li>
</ul>
<h4 id="objects">Objects</h4>
<ul>
<li>Everything is an object</li>
<li>See <code>objects.py</code></li>
<li>Any object can have a new field, that is &quot;attribute,&quot; added to it.</li>
</ul>
<h4 id="duck-typing">Duck Typing</h4>
<blockquote>
<p>If it waddles like a duck, quacks like a duck, and looks like a duck it is a duck.</p>
</blockquote>
<ul>
<li>Can you do operation O on data D?
<ul>
<li>Try it at run time and see if it raises and exception.</li>
</ul></li>
<li>Cf.Java: ensure at compile time that object is of type T and that any any object of type T can handle message with name O.</li>
</ul>
<h3 id="scope">Scope</h3>
<ul>
<li>The scope of a variable is the part of the program that can refer to that variable.</li>
<li>It's purpose is to limit the number of name &quot;in use&quot; at any one point.
<ul>
<li>To limit the number of names the programmer has to remember to avoid.</li>
<li>To limit the region in the program where a bug can change a variable name.</li>
</ul></li>
</ul>
<h4 id="nested-scope">Nested Scope</h4>
<ul>
<li>As in Scheme, also Algol, Pascal</li>
<li>Assumes languages already has nested constructs life nested if, nested loops, etc.</li>
<li>Some constructs create new variables and functions
<ul>
<li>Loop variables</li>
<li>Scope of a new name is the construct</li>
<li>Except where shadowed</li>
</ul></li>
</ul>
<p>Advantages | Disadvantages -----------|-------------- Simple | The struct isn't uniform Uniform | Functions Recursive | files Elegant | Varied size scope |</p>
<h3 id="parameters">Parameters</h3>
<h4 id="association">Association</h4>
<ul>
<li>Positional association
<ul>
<li>Arguments associated with formals one-by-one
<ul>
<li>C, Pascal, Scheme, Java</li>
</ul></li>
</ul></li>
<li>Keyword association
<ul>
<li>Ada uses a mixtures</li>
</ul></li>
</ul>
<h4 id="passing-modes">Passing Modes</h4>
<ul>
<li>Pass by value
<ul>
<li>C, Pascal, Ada, Scheme, Algol68</li>
</ul></li>
<li>Pass by result
<ul>
<li>Ada</li>
</ul></li>
<li>Pass by value result
<ul>
<li>Fortran, sometimes Ada</li>
</ul></li>
<li>Pass by reference
<ul>
<li>Fortran, Pascal var params, sometimes Cobol</li>
</ul></li>
<li>Pass by name (outmoded)
<ul>
<li>Algol60</li>
</ul></li>
</ul>
<h5 id="pass-by-value">Pass by Value</h5>
<pre><code>c: array [1..10] of integer; 
m,n : integer;
procedure r (k, j : integer) 
begin
    k := k+1;
    j := j+2; 
end r;
...
m := 5;
n := 3; r(m,n); 
write m,n;</code></pre>
<blockquote>
<p>Output: <code>5 3</code></p>
</blockquote>
<ul>
<li>Advantages
<ul>
<li>Argument protected from changes in callee</li>
</ul></li>
<li>Disadvantages
<ul>
<li>Copying of values takes executing time and space, especially for aggregate values.</li>
</ul></li>
</ul>
<h5 id="pass-by-result">Pass by Result</h5>
<pre><code>c: array [1..10] of integer; 
m,n : integer;
procedure r (k, j : integer) 
begin
    k := k+1;
    j := j+2; 
end r;
...
m := 5;
n := 3; 
r(m,n); 
write m,n;</code></pre>
<blockquote>
<p>Output: <code>6 5</code></p>
</blockquote>
<ul>
<li>Assume we have <code>procedure P(k, j : int)</code> with <code>k</code> and <code>j</code> as result parameters. What is the interpretation of <code>p(m,m)</code>?
<ul>
<li>Assume parameter <code>k</code> has value 2 and <code>j</code> has value 3 at end of <code>p</code>.
<ul>
<li>What value is <code>m</code> on return?</li>
</ul></li>
</ul></li>
</ul>
<h5 id="pass-by-value-result">Pass by Value-Result</h5>
<pre><code>c: array [1..10] of integer; 
m,n : integer;
procedure r (k,j : integer) 
begin
    k := k+1;
    j := j+2; 
end r;
...
m := 5;
n := 3; 
r(m,n); 
write m,n;</code></pre>
<blockquote>
<p>Output: <code>6 5</code></p>
</blockquote>
<h5 id="comparisons">Comparisons</h5>
<ul>
<li>Value-result
<ul>
<li>Has all the advantages and disadvantages of value and result together</li>
</ul></li>
<li>Reference
<ul>
<li>Advantage: more efficient than copying</li>
<li>Disadvantage: aliasing - when there are two or more different names for the same storage location
<ul>
<li>Side effect not visible from code itself.</li>
</ul></li>
</ul></li>
</ul>
<h3 id="parameter-passing-v2">Parameter Passing <small>v2</small></h3>
<h4 id="terms">Terms</h4>
<dl>
<dt>Function definition</dt>
<dd><p>Where the details of the function are presented.</p>
</dd>
<dt>Function call</dt>
<dd><p>Where the function is invoked.</p>
</dd>
<dt>Parameters</dt>
<dd><p>Names of local variables in function that are given during call.</p>
</dd>
<dt>Local variables</dt>
<dd><p>Variables in function that are given values during call.</p>
</dd>
<dt>Arguments</dt>
<dd><p>Values provided for parameters.</p>
</dd>
<dt>Parameter passing</dt>
<dd><p>Methods used to determine how argument values relate to parameters.</p>
</dd>
<dt>Overloading</dt>
<dd><p>When thje same function name can have one or more set of parameters</p>
</dd>
<dt>L-value</dt>
<dd><p>Location of the variable</p>
</dd>
<dt>R-value</dt>
<dd><p>Contents of the variable (or result of the expression)</p>
</dd>
</dl>
<h4 id="call-by-value">Call by Value</h4>
<ul>
<li>Calling mechanism
<ul>
<li>Arguments are evaluated for their values</li>
<li>Local variables created for each parameter</li>
<li>Values resulting from arguments copied to new parameter variables</li>
<li>When function call ends, parameter variables are discarded</li>
</ul></li>
<li>During function execution, value of parameters may diverge from argument values (function does not affect arguments)</li>
<li>Call by Value used in
<ul>
<li>C</li>
<li>Most C++ paremeters</li>
</ul></li>
<li>Variables are change in functions only indirectly
<ul>
<li>Point values are passed to functions</li>
<li>Variables that the point point at may be changed in a function</li>
</ul></li>
<li>Characteristics:
<ul>
<li>Variables may not directly be changed in function body</li>
<li>Arguments can be complex expressions</li>
<li>Mechanism is simple (easy to explain)</li>
</ul></li>
<li><p>Example</p>
<pre><code>int x = 1;

void func1 (int a) {
    // Location 2
    x = 2;
    // Location 3
    a = 5;
    // Location 4
}

void main () {
    // Location 1
    funct1(x);
    // Location 5
}</code></pre>
<table>
<thead>
<tr class="header">
<th align="left">Location</th>
<th align="left"><code>a =?</code></th>
<th align="left"><code>x =?</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="left">undefined</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="left">1</td>
<td align="left">2</td>
</tr>
<tr class="even">
<td align="left">4</td>
<td align="left">5</td>
<td align="left">2</td>
</tr>
<tr class="odd">
<td align="left">5</td>
<td align="left">undefined</td>
<td align="left">2</td>
</tr>
</tbody>
</table></li>
</ul>
<h4 id="call-by-reference">Call by Reference</h4>
<ul>
<li>Calling mechanism
<ul>
<li>Variables locations for arguments determined</li>
<li>Parameter names added to the location for each argument</li>
<li>When function call ends, extra names are discarded</li>
</ul></li>
<li>During function call, changes to referenced variables persist even after function ends.</li>
<li>Call by Reference used
<ul>
<li>Pascal</li>
<li>C++ (&amp; parameters)</li>
<li>Some version of FORTRAN</li>
</ul></li>
<li>Characteristics:
<ul>
<li>Changed to parameters change corresponding argument variables</li>
<li>Arguments must be variables</li>
</ul></li>
<li><p>Example</p>
<pre><code>int x = 1;

void func1 (int a) {
    // Location 2
    x = 2;
    // Location 3
    a = 5;
    // Location 4
}

void main () {
    // Location 1
    funct1(x);
    // Location 5
}</code></pre>
<table>
<thead>
<tr class="header">
<th align="left">Location</th>
<th align="left"><code>a =?</code></th>
<th align="left"><code>x =?</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="left">undefined</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="left">2</td>
<td align="left">2</td>
</tr>
<tr class="even">
<td align="left">4</td>
<td align="left">5</td>
<td align="left">5</td>
</tr>
<tr class="odd">
<td align="left">5</td>
<td align="left">undefined</td>
<td align="left">5</td>
</tr>
</tbody>
</table></li>
</ul>
<h4 id="call-by-value-result">Call by Value-Result</h4>
<ul>
<li>Calling mechanism
<ul>
<li>Arguments are evaluated for their values</li>
<li>Local variables created for each parameter</li>
<li>Values resulting from arguments coped to new parameter variables</li>
<li>When function call ends, values from parameters copied back to calling variables</li>
</ul></li>
<li>Operates like Call by Reference but differs under certain circumstances</li>
<li>Used in some versions of FORTRAIN, inout param in CORBA</li>
<li><p>Example</p>
<pre><code>int x = 1; // global x      
void func1 (int a) {            // Location 2           a = 3;          // Location 3           x = 4;          // Location 4       }       void main () {          // Location 1           func1(x);           // Location 5       }</code></pre>
<table>
<thead>
<tr class="header">
<th align="left">Location</th>
<th align="left"><code>a =?</code></th>
<th align="left"><code>x =?</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="left">undefined</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="left">3</td>
<td align="left">2</td>
</tr>
<tr class="even">
<td align="left">4</td>
<td align="left">3</td>
<td align="left">4</td>
</tr>
<tr class="odd">
<td align="left">5</td>
<td align="left">undefined</td>
<td align="left">3</td>
</tr>
</tbody>
</table></li>
</ul>
<h2 id="december-15th-2013-practice-final-exam">December 15th, 2013 <small>Practice Final Exam</small></h2>
<h3 id="question-1">Question 1</h3>
<p>Each of the following, involves a language over the four characters a, b, c, and d. For each one either give a Regular Expression that generates the language or explain why this is impossible:</p>
<ol style="list-style-type: decimal">
<li><p>L = The set of strings that start with three or more a’s followed by any number (including 0) of a’s and b’s.</p>
<pre><code>(aaa)(a|b*)</code></pre></li>
<li><p>L = The set of strings in which every ‘a’ is followed immediately by a ‘b’ and every ‘b’ is immediately preceded by an ‘a’., and similarly for ‘c’ and ‘d’. In other words, the strings must be made up of combinations of ab and cd. E.g., ‘abcdab’ is in L but ‘abccd’ is not.</p>
<pre><code>((ab)|(cd))*</code></pre></li>
</ol>
<h3 id="question-2">Question 2</h3>
<p>Consider the following FSA:</p>
<div class="figure">
<img src="../img/cs-pl-final-fsa.png" alt="Finite State Automata Diagram" /><p class="caption">Finite State Automata Diagram</p>
</div>
<ol style="list-style-type: decimal">
<li>Is this a deterministic or non-deterministic FSA? Why?
<ul>
<li>A non-deterministic FSA has at least one state which has two arrows with the same label or an epsilon transisition.</li>
<li>So this one is deterministic.</li>
</ul></li>
<li><p>Write a regular expression that specifies the same language that this FSA accepts.</p>
<pre><code>(b|m)(a)((d|n)(x))*</code></pre></li>
<li><p>Complete the following grammar for the language this FSA accepts:</p>
<pre><code>S      -&gt; PREFIX | PREFIX TAIL
PREFIX -&gt; BORM a</code></pre>
<ol style="list-style-type: decimal">
<li><code>BORM -&gt; b | m</code></li>
<li><code>TAIL -&gt; NORD x | NORD x TAIL</code></li>
<li><code>NORD -&gt; n | d</code></li>
</ol></li>
</ol>
<h3 id="question-3">Question 3</h3>
<p>In the following Scheme function, <code>num-list</code> is a list of numbers and threshold is a single number. The function <code>list-greater</code> returns a <code>list</code> equal in length to <code>num-list</code> but with each number replaced by either <code>#t</code> or <code>#f</code>, depending on whether the number is or is not greater than threshold. E.g., <code>(list-greater '(2 5 3 6) 4))</code> should return <code>(#f #t #f #t)</code>. Finish the definition below. You must use <code>map</code><sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup>.</p>
<pre><code>(define (list-greater num-list threshold)
    (map (lambda(x)(x &gt; threshold)) num-list)
)</code></pre>
<h3 id="question-4">Question 4</h3>
<p>The following Scheme code defines <code>sumsqtr</code>, a function that takes a list of numbers as its argument and returns the sum of the squares of those numbers. Eg <code>(sumsqtr '(1 4))</code> returns <code>17</code>. <code>Sumsqtr</code> and its helper function <code>sumsqtrh</code> are tail recursive. Fill in the blanks.</p>
<pre><code>(define (sumsqtr lst)
    (sumsqtrh lst 0))
(define (sumsqtrh lst accum)
    (if (null? lst) accum
        (sumsqtrh (crd lst)
                    (+ accum (* car let)(car list)))
    ))</code></pre>
<h3 id="question-5">Question 5</h3>
<ol style="list-style-type: decimal">
<li><p><code>inOrder(List)</code>. Assume List is a list of numbers; <code>inOrder(List)</code> is true if and only if the numbers in List are in increasing order. If List has <code>0</code> or <code>1</code> element it is in order.</p>
<pre><code>inOrder( [] ).
inOrder( [_] ).
inOrder([N1, N2 | T]) :- N1 &lt; N2, inOrder[N2 | T]</code></pre></li>
<li><p>Suppose a graph is represented as a list of node structures like <code>node(a, 3, [b, c])</code> where a is the node's name, 3 is its color, and <code>[b, c]</code> is a list of its neighbors' names. The predicate <code>allNames(Graph, Names)</code> assumes <code>Graph</code> is a graph and binds <code>Names</code> to a list of all the names of nodes in the graph (just the names, not the node(...) structures).</p>
<pre><code>allNames( ??? , ??? ).
allNames( ??? , ??? ) :- ??? .</code></pre></li>
</ol>
<h3 id="question-6">Question 6</h3>
<p>Given the rules</p>
<pre><code>suffix([H | T], T).
suffix([H | T], T1):- suffix( T, T1 ).</code></pre>
<ol style="list-style-type: decimal">
<li>What would be the first result of the query <code>suffix([a, b, c], S)</code>?</li>
<li>What would be the second result of the query, if the user typed ‘;’ after the first result?</li>
</ol>
<h3 id="question-7">Question 7</h3>
<pre><code>int a;

procedure foo(int x) {
    x = x + 10;
    a = a + x;
}

procedure fie( ) {
    a = 5;
    foo(a);
    print (a);
}</code></pre>
<p>For each of the following parameter passing methods, show what would be printed by a call to fie.</p>
<ol style="list-style-type: decimal">
<li>Call by value</li>
<li>Call by value-result</li>
<li>Call by reference</li>
</ol>
<h3 id="question-8">Question 8</h3>
<p>For each of the following language features, circle “functional” if having the feature makes a language more of a functional language and “not” if it does not:</p>
<table>
<thead>
<tr class="header">
<th align="left">Feature</th>
<th align="left">Functional?</th>
<th align="left">Why?</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">closures</td>
<td align="left">Yes</td>
<td align="left">They're little functions.</td>
</tr>
<tr class="even">
<td align="left">arrays</td>
<td align="left">No</td>
<td align="left">They're not functions.</td>
</tr>
<tr class="odd">
<td align="left">dynamic types</td>
<td align="left">No</td>
<td align="left">Probably not functions.</td>
</tr>
<tr class="even">
<td align="left">garbage collection</td>
<td align="left">Yes</td>
<td align="left">Lets you just do functions.</td>
</tr>
<tr class="odd">
<td align="left">linked-lists are a built-in data type</td>
<td align="left">No</td>
<td align="left">Not functions.</td>
</tr>
</tbody>
</table>
<h3 id="question-9">Question 9</h3>
<p>Given the declarations below:</p>
<pre><code>int: size, size2, j;
float: x;
array[1:30] of int: nums;</code></pre>
<p>For the assignment statements below, circle the ones that cannot be fully type- checked at compile time. Assume that an array’s subscript range is considered part of its type. Assume that numeric overflow and is not considered a type-error.</p>
<ol style="list-style-type: decimal">
<li>size = size2 + 1;</li>
<li>x = size;</li>
<li>nums[j]=33;</li>
<li>nums[3] = nums[4];</li>
<li>nums[j] = nums[j+1]</li>
</ol>
<h3 id="question-10">Question 10</h3>
<p>The following python function takes a list of numbers as its argument and returns a list of the squares of those numbers. Finish it.</p>
<pre><code>def listSq(lst):</code></pre>
<p>*[FSA]: Finite State Automaton</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>How does map work? It transforms a list by applying a function to each of its members. Furthermore, it returns the transformed list. Map takes a function and then a list.</p>
<pre><code>elements(map (lambda (x) (* x 2)) numbers)</code></pre>
<a href="#fnref1">↩</a></li>
</ol>
</div> 
{% endraw %}