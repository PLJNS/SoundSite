---
layout: page
title: Notes
subtitle: From Paul Jones at Rutgers University
---
{% raw %}
<h1>
Computer Architecture <small>with Professor Brian Russell</small>
</h1>

<h2>
Description
</h2>

<p>
This course covers the fundamental issues in the design of modern computer systems, including the design and implementation of key hardware components such as the processor, memory, and I/O devices, and the software/hardware interface.
</p>

<ul>
<li>
<p>Topics:</p>
<ul>
<li>
C programming
</li>
<li>
Data representation and computer arithmetic
</li>
<li>
Assembly language programming
</li>
<li>
Boolean algebra
</li>
<li>
Basic digital logic design
</li>
<li>
Processor design
</li>
<li>
Cache design
</li>
<li>
Main memory design
</li>
</ul></li>
</ul>

<h2>
Syllabus
</h2>

<ul>
<li><p>
Instructor: Brian Russell
</p>

<ul>
<li>
<a href = "mailto:morbius@cs.rutgers.edu">Email</a>
</li>
<li>
Office Hours: Wednesdays 8:00-9:00 pm, Hill 403.
</li>
</ul></li>
<li><p>
TAs
</p>

<ul>
<li><p>
Yuanzhen Gu
</p>

<ul>
<li>
<a href = "mailto:yg185@cs.rutgers.edu">Email</a>
</li>
<li>
Office Hours: Thursdays, 3:00-4:00 pm, Hill 418
</li>
</ul></li>
<li><p>
Longhao Shu
</p>

<ul>
<li>
<a href = "mailto:ls675@cs.rutgers.edu">Email</a>
</li>
<li>
Office Hours: Thursdays, 5:00-6:00 pm, Hill 416
</li>
</ul></li>
<li><p>
Chaowei Tan
</p>

<ul>
<li>
<a href ="mailto:ct382@cs.rutgers.edu">Email</a>
</li>
<li>
Office Hours: Fridays, 9:00-10:00 am, Hill 488
</li>
</ul></li>
<li><p>
Vilemini Kalambratsidou
</p>

<ul>
<li>
<a href = "mailto:vilelmini.kalabratsidou@gmail.com">Email</a>
</li>
<li>
Office Hours: Wednesdays 10:00 am-Noon, Hill 410
</li>
</ul></li>
</ul></li>
</ul>

<h3>
Objective
</h3>

<p>
The aim of CS 211 is to provide an understanding of the fundamental logical organization of a computer (its parts and their relationship) and how it actually works; exposure to a central processor's native language, and to basic computer components. Basic Architecture for high performance design.
</p>

<h3>
Prerequisite Knowledge
</h3>

<ul>
<li><p>
Prior programming experience in a high-level language (such as Java).
</p></li>
<li><p>
01:198:112. Credit not given for this course and 14:332:331.
</p></li>
</ul>

<h3>
Topics
</h3>

<p>
The following list is organized by topic, not by chronological order of coverage in the course.
</p>

<ol>
<li><p>
Von Neumann Architecture, Hardware trends, Importance of Speed, Cost, Energy
</p></li>
<li><p>
Intro to C programming
</p></li>
<li>
Data Representation, Computer Arithmetic
</li>
<li>
Assembly language techniques, including macro-instruction definition
</li>
<li>
Digital logic, registers, instruction counter
</li>
<li>
Processor Architecture
</li>
<li>
Pipelining
</li>
<li>
Memory hierarchies, Caching (L0, L1, L2 caches)
</li>
<li>
Virtual Memory
</li>
<li>
Interrupts
</li>
<li>
Input and Output, buses
</li>
</ol>

<h3>
Schedule
</h3>

<ol>
<li>
Jan 22 Into to hardware trends, Moore's law. Chap 1.
</li>
<li>
Jan 24 Into to C programming
</li>
<li>
Jan 29 C program structure, control flow structures
</li>
<li>
Jan 31 Pointers and arrays, C functions
</li>
<li>
Feb 05 Dynamic memory management
</li>
<li>
Feb 07 C preprocessor, formatted I/O
</li>
<li>
Feb 12 Data representation. Chap 2.1 2.2 2.4.
</li>
<li>
Feb 14 Computer Arithmetic.31
</li>
<li>
Feb 19 Assembly Language Programming Chap 3.
</li>
<li>
Feb 21 Assembly Language Programming
</li>
<li>
Feb 26 Assembly Language Programming
</li>
<li>
Feb 28 Assembly Language Programming
</li>
<li>
Mar 05 Assembly Language Programming
</li>
<li>
Mar 07 Assembly Language Programming
</li>
<li>
Mar 12 Spring Break -- no class
</li>
<li>
Mar 14 Spring Break -- no class
</li>
<li>
Mar 19 Digital Logic Chap 4.2
</li>
<li>
Mar 21 Digital Logic
</li>
<li>
Mar 26 Processor Design
</li>
<li>
Mar 28 Midterm
</li>
<li>
Apr 02 Processor Design
</li>
<li>
Apr 04 Processor Design
</li>
<li>
Apr 09 Processor Design
</li>
<li>
Apr 11 Caches
</li>
<li>
Apr 16 Caches
</li>
<li>
Apr 18 Caches
</li>
<li>
Apr 23 Caches
</li>
<li>
Apr 25 I/O and Disks
</li>
<li>
Apr 30 Review
</li>
</ol>

<h3>
Expected Work
</h3>

<p>
Students are expected to attend all lectures and perform all reading assignments prior to lecture. Students are also expected to attend all recitation section meetings. Students will be evaluated according to their performance on four programming projects, programming project, a mid-term examination, and a final examination.
</p>

<h3>
Grading
</h3>

<ul>
<li><p>
40% Correctness
</p>

<ul>
<li>
Percent based on number of test cases
</li>
</ul></li>
<li><p>
40% Code Quality
</p>

<ul>
<li>
20% Algorithmic
</li>
<li>
10% Reusability/Modularity
</li>
<li>
10% Decomposition
</li>
</ul></li>
<li><p>
20% Documentation
</p>

<ul>
<li>
10% Test Cases from Students
</li>
<li>
5% Comments
</li>
<li>
5% Documentation (Analysis, readme files, etc...)
</li>
</ul></li>
</ul>

<h3>
Project Warning
</h3>

<p>
This is a project course, which means that this course should give you more than a passing knowledge of computer architecture. The project work will be a major undertaking. If you complete the projects, you will have learned a lot. However, assess your commitment to this course realistically. If you don't have the time or the inclination to work hard on the project, you would be better off not taking the course. You will have to learn how to build and debug C and Assembly programs and make them robust to outside errors. You will also have to describe how your program work in a written document. There are three or four programming assignments. Students are required to complete the parts by the scheduled deadlines. Failure to turn in the project by the deadline using the electronic handin website will result in a zero grade. No exceptions! There are many different operating systems and variants of C out there and we cannot test your program on all of them. So all program assignments must run on the local iLab Linux machines. We will be grading your assignments on those machines as well.
</p>

<h3>
Working Together and Academic Honesty
</h3>

<p>
Cheating on projects and exams will not be tolerated. We want to protect the fairness and integrity of the class, so we run code similarity detectors on the projects and scrutinize exams for copying. Both parties in the exchange are liable; e.g. if you give away solutions to friends, you're putting yourself at risk too. If you get caught, it's a nasty process---| just don't go there! You're better off asking for help, or at worst, dropping the course and trying it again. The department academic integrity policy can be found at <a href="http://www.cs.rutgers.edu/policies/academicintegrity/">here</a>. You now need to click explicitly on a link when first login to our computing facilities,use handin, etc., that says you acknowledge being aware of the policy (which you can read through the login screen). If you fail to do the click-through by the end of September, your access to our facilities will cease October 1.
</p>

<h4>
The Gilligan's Island Rule
</h4>

<p>
We do encourage you to talk to your classmates, provided you follow the Gilligan's Island Rule. After a joint discussion of an assignment or problem, each student should discard all written material and then go do something mind-numbing for half an hour. For example, go watch an episode of Gilligan's Island (or jersey Shore in modern terms), and then recreate the solutions. The idea of this policy is to ensure that you fully understand the solutions or ideas that the group came up with. If you follow the Gilligan's island rule, often best route to follow to get a question answered is to ask, in order: 1. A classmate smarter than you. 2. Your TA. 3. The professor.
</p>

<h2>
January 22nd, 2013 - Lecture: Hardware trends, Moore's law, Chapter 1
</h2>

<ul>
<li><p>
The modern computer is a general purpose computer which stores programs as data.
</p></li>
<li><p>
The hardware understands the encoded instructions and reacts predictably.
</p></li>
<li><p>
The way the hardware executes a program is specific to the hardware, yet with similar results.
</p></li>
<li><p>
We'll look at assembly for the Intel structure.
</p></li>
<li>
Instructions as data - ones and zeros.
</li>
<li><p>
Main components of computer
</p>

<ul>
<li>
CPU
</li>
<li><p>
Memory
</p>

<ul>
<li><p>
It is sometimes still called &quot;core memory&quot; for hustorical reasons.
</p></li>
<li><p>
It is now &quot;transistorized&quot;, computer programs &quot;barf and die.&quot;
</p></li>
<li><p>
It is random access - it can be done in constant time.
</p></li>
<li>
It is volatile - turn the power off and memory is gone.
</li>
</ul></li>
<li><p>
Bus
</p></li>
<li>
<p>I/O devices</p>
<ul>
<li>
Human interface
</li>
<li>
Storage
</li>
<li>
Network cards
</li>
<li>
Graphics cards
</li>
</ul></li>
</ul></li>
<li><p>
Control flow - any computer program can be written as three things:
</p>

<ol>
<li>
sequencing,
</li>
<li>
alteration, and
</li>
<li>
repetition
</li>
</ol></li>
<li><p>
Von Neumann Model
</p>

<ul>
<li><p>
Fetch and execute cycle
</p>

<ul>
<li><p>
What the CPU is doing is taking a bunch of instructions physcially next to each other in memory.
</p></li>
<li><p>
The Intel architecture, and I love this, takes the address <code>0xFFFFFFF0</code> to boot the machine.
</p></li>
<li><p>
First step is the fetch cycle, go get the instruction at the startup address.
</p></li>
<li><p>
Then decode the instruction, what is encoded? What do I do with it?
</p></li>
<li><p>
There are input operands on the instructions.
</p></li>
<li>
Then execute the operation, put the operations back on the register operands, get the pointer to the next instruction.
</li>
</ul></li>
<li><p>
This guy got credit for work that was done previously, by Alan Turing.
</p></li>
<li><p>
This was known as the &quot;Turing Machine&quot;, which was a theoretical machine at the time.
</p></li>
<li><p>
A few other contempories applied for pantents about instructions in memory.
</p></li>
<li><p>
There was some dispute with Von Neumann and drafts and whose names appeared.
</p></li>
<li><p>
A CPU and memory are connected by a bus.
</p></li>
<li>
The Von Neumann bottleneck.
</li>
</ul></li>
<li><p>
Moore's law
</p></li>
</ul>

<h2>
January 22nd, 2013 - Assignment 1: Wordstat
</h2>

<h3>
Introduction
</h3>

<p>
This assignment is designed to get you some initial experience with programming in C, as well as compiling, linking, running, and debugging a C program in our environment.
</p>

<p>
Your task is to write a C program called <code>wordstat</code> that reads a text file, finds all the unique words in the file, prints them in lexicographical order along with the total number of times each word appears (case-insensitive) and a count of different case-sensitive versions of the word.
</p>

<p>
A word is defined as any sequence of letters (A-Z, a-z) and digits (0-9) that starts with a letter, followed by 0 or more letters and/or digits. This definition is equivalent to the following regular expression:
</p>

<pre><code>([A-Z]|[a-z])([A-Z]|[a-z]|[0-9])*
</code></pre>

<p>
Words in the input file correspond to the longest sequences that match the above expression when reading the file from beginning to end. Each unique word is case-insensitive. That is, “book” and “Book” and “bOOk” are all occurrences of the same word. However, they represent three different case-sensitive versions of the word “book”.
</p>

<p>
As an example, running <code>wordstat</code> on a text file with the following content:
</p>

<pre><code>Some Bogus ?Random1&gt; (random1modnar) [34ranDom1] (Random1) boGus-$con@tent.
</code></pre>

<p>
should produce:
</p>

<pre><code>Word            Total No. Occurrences   No. Case-Sensitive Versions
bogus           2                       2
con             1                       1
random1         3                       2
random1modnar   1                       1
some            1                       1
tent            1                       1
</code></pre>

<h3>
Implementation
</h3>

<p>
Implement a program called <code>wordstat</code> with the following usage interface:
</p>

<pre><code>wordstat &lt;argument&gt;
</code></pre>

<p>
where <code>&lt;argument&gt;</code> is either the name of the file that <code>wordstat</code> should process, or -h, which means that <code>wordstat</code> should print out a help menu to guide the user on how to use the program.
</p>

<p>
As discussed above, when invoked with a valid file name, <code>wordstat</code> should find and output all the unique words in the file in lexicographical order, along with the total number of times each word appears (case-insensitive) and a count of different case-sensitive versions of the word.
</p>

<p>
We leave the choice of data structures and algorithms up to you. However, your implementation must be reasonably efficient. For example, maintaining an array of records and doing linear search through this array would be unacceptable. You are allowed to use functions from standard libraries (e.g., <code>strcmp()</code>) but you cannot use third- party libraries downloaded from the Internet (or from anywhere else). If you are unsure whether you can use something, ask us. We will compile and test your program on the iLab machines so you should make sure that your program compiles and runs correctly on these machines. You must compile all C code using the gcc compiler with the <code>-ansi -pedantic -Wall</code> flags.
</p>

<h3>
Submission
</h3>

<p>
You have to e-submit the assignment using Sakai. Your submission should be a tar file named pa1.tar. To create this file, put everything that you are submitting into a directory (folder) named pa1. Then, cd into the directory containing pa1 (that is, pa1’s parent directory) and run the following command:
</p>

<pre><code>tar cvf pa1.tar pa1
</code></pre>

<p>
To check that you have correctly created the tar file, you should copy it (pa1.tar) into an empty directory and run the following command:
</p>

<pre><code>tar xvf pa1.tar
</code></pre>

<p>
This should create a directory named pa1 in the (previously) empty directory. The pa1 directory in your tar file must contain: * readme.pdf: This file should briefly describe the main data structures being used in your program, a big O analysis of the run time and space requirement of your program, and any challenges you encounter in this assignment * Makefile: there should be at least two rules in your Makefile: 1. <code>wordstat</code>: build your <code>wordstat</code> executable. 2. clean: prepare for rebuilding from scratch. * source code: all source code files necessary for building <code>wordstat</code>. Your source code should * contain at least 2 files: <code>wordstat.h</code> and <code>wordstat.c</code>.
</p>

<p>
We will provide a small script that you can use to check for the above required items. You do not have to run it, but it might help you to check that you are handing in everything that we are asking for.
</p>

<h3>
Grading Guidelines
</h3>

<h4>
Functionality
</h4>

<p>
This is a large class so that necessarily the most significant part of your grade will be based on programmatic checking of your program. That is, we will build a binary using the Makefile and source code that you submitted, and then test the binary for correct functionality against a set of inputs. Thus: * You should make sure that we can build your program by just running make. * You should test your code as thoroughly as you can. In particular, your code should be adept at handling exceptional cases. For example, <code>wordstat</code> should not crash if the argument file does not exist.
</p>

<p>
Be careful to follow all instructions. If something doesn’t seem right, ask.
</p>

<h4>
Design
</h4>

<p>
Having said the above about functionality, design is a critical part of any programming exercise. In particular, we expect you to write reasonably efficient code based on reasonably performing algorithms and data structures. More importantly, you need to understand the performance (time &amp; space) implications of the algorithms and data structures you chose to use. Thus, the explanation of your design and big O analyses in the readme.pdf will comprise a non-trivial part of your grade. Give careful thoughts to your writing of this file, rather than writing whatever comes to your mind in the last few minutes before the assignment is due.
</p>

<h4>
Coding Style
</h4>

<p>
Finally, it is important that you write “good” code. Unfortunately, we won’t be able to look at your code as closely as we would like to give you good feedback. Nevertheless, a part of your grade will depend on the quality of your code. Here are some guidelines for what we consider to be good: * Your code is modularized. That is, your code is split into pieces that make sense, where the pieces are neither too small nor too big. * Your code is well documented with comments. This does not mean that you should comment every line of code. Common practice is to document each function (the parameters it takes as input, the results produced, any side-effects, and the function’s functionality) and add comments in the code where it will help another programmer figure out what is going on. * You use variable names that have some meaning (rather than cryptic names like i). Further, you should observe the following protocols to make it easier for us to look at your code: * Define prototypes for all functions. * Place all prototype, typedef, and struct definitions in header (.h) files. * Error and warning messages should be printed to stderr using fprintf.
</p>

<h2>
January 24th, 2013 - Lecture: Introduction to C programming
</h2>

<ul>
<li>
<code>.java</code> -&gt; <code>.class</code> (machine independant)
</li>
<li>
<code>c</code> code -&gt; machine / OS specific -&gt; executable
</li>
<li><p>
&quot;Hello world&quot; in C
</p>

<pre><code>#include &lt;stdio.h&gt;
int
main() {
    printf("cogito ero sum\n");
    return 0;
}
</code></pre></li>
<li><p>
To run the program above, <code>cogito.c</code>:
</p>

<pre><code>gcc cogito.c
gcc -o cogito cogito.c
gcc -c cogito.c
gcc cogito.o
</code></pre></li>
<li><p>
command line arguments:
</p>

<pre><code>#include &lt;stdio.h&gt;
int
main(int argc, char**argv) {
    int i;
    for(i = 0; i &lt; argc, i++) {
        printf("arg %d is %s\n", i, argv[i]);
    }
</code></pre></li>
<li><p>
structs
</p>

<ul>
<li>
there are no constructors
</li>
<li>
there are no member functions
</li>
<li>
there are no visibility restrictions (all public)
</li>
<li>
no need for dynamically allocating them
</li>
</ul></li>
</ul>

<h2>
January 29th, 2013 - Lecture: C program structure, control flow structures
</h2>

<ul>
<li><p>
Sometimes we as programmers we need some a variable that can only take on a few values.
</p></li>
<li><p>
Java, evidently, screwed this up.
</p>

<pre><code>enum stoplight {
    red,yellow,green
}

enum stoplight x;
int y;
x = red;
y = green;
x = (enum stoplight) 37;
</code></pre></li>
<li><p>
The internal numbering scheme for this unmodified syntax makes:
</p>

<ul>
<li>
<code>red = 1</code>
</li>
<li>
<code>yellow = 2</code> and
</li>
<li>
<code>green = 3</code>
</li>
</ul></li>
<li><p>
If the first line was <code>red = 5</code>, then the following values would be incremeneted from that.
</p></li>
<li><p>
<code>typedef</code>
</p>

<pre><code>typedef int size;
</code></pre>

<ul>
<li>
my ability to decalre an alias for a new type
</li>
<li>
now I get to say things like <code>size x,y</code>
</li>
<li>
I am defining an alias for an existing type.
</li>
</ul></li>
<li><p>
<code>struct</code>
</p>

<pre><code>typedef struct pt {
    int x,y;
} point;

point left_bot, right_top;
</code></pre></li>
<li><p>
<code>sizeof</code>
</p>

<pre><code>sizeof unary-expression;
sizeof (typename)
&amp; // "give me the address of this variable"
* // unary prefix operator - "d-reference pointer"
, // underutilized in java and c - "me seperating multiple expression"
-&gt; // "I use that to get at pointers or members of struct"
</code></pre></li>
<li><p>
To prompt for input
</p>

<pre><code>while(printf("enter an integer&gt;&gt;"),scanf("%d",$x)&gt;0) {
    printf("%d\n",x);
}
</code></pre></li>
<li><p>
Pointers
</p>

<pre><code>int *p;
int x;
</code></pre>

<ul>
<li><p>
In C, C++ you get pointers, which are the address in memory of an variable.
</p></li>
<li><p>
<code>p</code> is a pointer to an integer
</p></li>
</ul></li>
<li><p>
functions
</p>

<pre><code>void
swap(int *p1, int *p2) {
    int temp;
    temp = *p1;
    *p1 = *p2;
    *p2 = temp;
}
</code></pre>

<ul>
<li>
this is afunction in C that swaps two values
</li>
<li><p>
if you try to pass two integers directly, the compiler will complain
</p></li>
<li><p>
I want to pass something that I want to change, and if I want to do that, I should pass the address of what I want to change.
</p></li>
</ul></li>
<li><p>
Pointers and arrays
</p>

<pre><code>int *p, A[10],x;

p = &amp;A[0]; // the address of an int I can put in a pointer
p = A; // the name of an array, A with no subscripts, is the address to the array
x = *p; //

p[1] = 5; // p is still a reference to apoointer, but I get to use subscripts
*(p+1) = 5 // identical to above
++p;
P++;
</code></pre></li>
<li><p>
void star
</p>

<pre><code>void *p;
int *pi;
float * pf;

p = pi;
p = pf;
pf = (float *)p;
pi = (int *)p;
</code></pre></li>
<li><p>
array addresses
</p>

<pre><code>int
main() {
    int A[10],I;
    printf("addr of i is %#x\n",&amp;I);
    for (int i = 0; i&lt;=10;i++) {
        printf("addr of A[%d] is %#x\n",i,&amp;A[i]);
        A[i]=0;
    }
}
</code></pre></li>
<li><p>
strings
</p>

<pre><code>char * p3 = "hello";
char array[] = "hello";
char a2[10] = "hello";
</code></pre></li>
</ul>

<h2>
January 30th, 2013 - Office hours
</h2>

<ul>
<li><p>
Linux is a descendant if UNIX, which is derivative from command line operating systems from Bell labs.
</p></li>
<li><p>
The wanted a nice, modular OS.
</p></li>
<li>
There's a directory structure. Everyone has a &quot;subtree&quot;
</li>
<li>
gcc commands
</li>
<li><p>
cat - concatenate files
</p>

<ul>
<li>
essentially, this prints,
</li>
<li>
this puts it on the screen
</li>
<li>
if you put a bunch in the command, it outputs them all.
</li>
<li>
you can redirect: 'cat a.c b.c d.c &gt; big.c`
</li>
<li>
you can append using <code>&gt;&gt;</code>
</li>
</ul></li>
<li><p>
we can copy and move files around
</p>

<ul>
<li>
<code>mv ...</code>
</li>
</ul></li>
<li><p>
<code>date</code> tells you the time of day and the date
</p></li>
<li>
<code>diff</code> tells you the difference between two files
</li>
<li><p>
<code>grep regexp [files]</code>
</p>

<ul>
<li>
this is only in the present directory
</li>
</ul></li>
<li><p>
<code>find</code> goes through folders and files recursively
</p></li>
<li>
<code>man</code> gets a manual
</li>
<li><p>
<code>ls</code> and <code>mkdir [name]</code>
</p>

<ul>
<li>
<code>-F</code> will distinguish between exe, subdirectory, etc.
</li>
</ul></li>
<li><p>
linux does not care about suffixes
</p></li>
<li><p>
<code>pg</code> or <code>more</code>: &quot;I want to see the file, but it might be larger than my screen.&quot;
</p></li>
<li><p>
<code>ps</code> for &quot;process status&quot;
</p></li>
<li>
<code>rm</code> and <code>rmdir</code> for &quot;remove&quot; and &quot;remove directory&quot;
</li>
<li>
<code>pwd</code>: &quot;I am printing the working directory&quot;
</li>
<li>
<code>who</code>: who else, including you, is on the system
</li>
</ul>

<h2>
January 31st, 2013 - Lecture: Pointers and arrays, C functions
</h2>

<ul>
<li><p>
String functions ('&lt;string.h&gt;')
</p>

<pre><code>char * strcpy(char * s1. const char * s2); // string copy
char * strncpy(char * s1, const char * s2, int n); // up to n bytes
char * strcat(char * s1, const char * s2); // string concatenate
char * strncat(char * s1, const char * s2, int n); // up to n bytes
int strcmp(const char * s1, const char * s2); // string compare
int strncmp(const char * s1, const char *s2, int n); // upt to n bytes
int stricmp(const char * s1, const char *s2, int n); // case insensitive
int strlen(const char * s); // number of bytes
</code></pre>

<ul>
<li>
<code>strncopy</code> says I will copy at most <code>n</code> bytes.
</li>
<li>
both of these argument pointers better be set to something valid in memory.
</li>
</ul></li>
<li><p>
Something with memory
</p>

<pre><code>void * memcpy(void * s1, const void * s2, int n);
int memcmp (const void *s1, const void *s2, int n);
void * memset (char * s1, char c, int n);
</code></pre></li>
<li><p>
Header files
</p>

<ul>
<li><p>
Sample header
</p>

<pre><code>#ifndef point_h
#define point_h

struct point {
    int x,y;
};
#include "other.h"
#endif
</code></pre></li>
<li><p>
Things to put in a header file
</p>

<ul>
<li>
Things to share
</li>
<li>
Trees, lists, something
</li>
<li>
Linked list operations
</li>
<li>
Definitions of nodes
</li>
<li>
Types I make up, <code>structs</code>, <code>enums</code>, <code>typedefs</code>
</li>
<li>
Functions I want to use
</li>
</ul></li>
</ul></li>
<li><p>
Dynamic memory allocation
</p>

<ul>
<li><p>
Three operations:
</p>

<ol>
<li>
<code>malloc</code>
</li>
<li>
<code>realloc</code>
</li>
<li>
<code>free</code>
</li>
</ol></li>
<li><p>
Definitions:
</p>

<pre><code>void * malloc(size_t size);
void * realloc (void * p, size_t newsize);
void free(void*);
</code></pre></li>
</ul></li>
</ul>

<h2>
February 5th, 2013 - Recitation
</h2>

<ul>
<li><p>
The <code>include</code> command is used to use other code in your <code>.c</code> files, you include <code>.h</code> files.
</p></li>
<li><p>
Typical files to include are <code>stdio.h</code> and <code>stdlib.h</code> (standard input/output and library, respectively).
</p>

<pre><code>[return_type] [function_name] ([datatype arg1, ... ) {
    [function body]
}
</code></pre></li>
<li><p>
Because C is parsed line by line, you must define a function before you use it otherwise it doesn't know it exists.
</p></li>
<li><p>
So you can make a function prototype.
</p>

<pre><code>[return_type] [function_name] ([datatype arg1, ... )
</code></pre></li>
<li><p>
You should include these things before <code>main</code>.
</p></li>
<li><p>
<code>fopen</code> and <code>fclose</code> are commands you use one <code>FILE</code>s to get information from them.
</p>

<ul>
<li><p>
Specify parameters for read, write, etc.
</p>

<pre><code>FILE * fopen(const char * filename, const char * mode);
FILE * fclose(const char * filename);
</code></pre></li>
</ul></li>
<li><p>
<code>fscanf</code> and <code>fprint</code>
</p>

<pre><code>fscanf(FILE *fp, "%d", &amp;age);
fprintf(FILE *fp, "%d", age);
</code></pre></li>
<li><p>
String specifiers
</p>

<ul>
<li>
<code>%d</code> is an integer
</li>
<li>
<code>%f</code> is a float
</li>
<li>
<code>%s</code> is
</li>
</ul></li>
<li><p>
<code>fputs</code> and <code>puts</code>
</p>

<pre><code>fputs(char *str, FILE *fp);
puts(char *str);
</code></pre></li>
<li><p>
<code>fwrite</code> and <code>fread</code>
</p>

<pre><code>int fwrite(*buf, int size, int count, FILE *fp);
</code></pre>

<ul>
<li>
<code>*buf</code> is the pointer
</li>
<li>
<code>size</code> is the size of data type
</li>
<li>
<code>count</code> is ...
</li>
<li>
<code>*fp</code> is the file in question
</li>
</ul></li>
<li><p>
Example
</p>

<pre><code>#include &lt;stdio&gt;
#include &lt;stderr&gt;

main() {
    float f1, f2, f3, f4;
    file *fp;
    if ((fp = fopen("file.txt", "r")) = null) {
        fprint("stderr, "Error: could not read file. \n");
    }
    fscanf(fp, "%f %f %f %f", &amp;f1, &amp;f2, &amp;f3, &amp;f4);
    fclose(fp);
    return 0;
}
</code></pre></li>
</ul>

<h2>
February 5th, 2013 - Lecture: Dynamic memory management
</h2>

<pre><code>    #include &lt;stdio.h&gt;
    int printf(const char *, ...);
    int fprintf(FILE *, const char *, ...);
    int sprintf(char *, const char *, ...); // value of this is the length of string created
    -[character] %[-][width]c \\ %c %3c %-3c
    %[-][#][width][l]
</code></pre>

<blockquote>
  <p>
Don't change the program, change the goals
</p>
</blockquote>

<pre><code>     int scanf(const char * fmt, ...);
</code></pre>

<ul>
<li>
remember, C passes by value, so pass the address of the thing you want to change.
</li>
</ul>

<h2>
February 7th, 2013 - Lecture: C preprocessor, formatted I/O
</h2>

<ul>
<li><p>
To print an error,
</p>

<pre><code>fprintf(stderr, "fmt string", ...);
</code></pre></li>
<li><p>
Some code
</p>

<pre><code>size_t fread(void * ptr, size_t size, sizeIt nobj, file *);
</code></pre>

<ul>
<li>
<code>void * ptr</code> is the input buffer
</li>
<li>
<code>size_t size</code> is the element size
</li>
<li>
<code>size_t nobj</code> is the number of objects
</li>
</ul></li>
<li><p>
<code>fwrite</code>
</p>

<pre><code>fwrite(const void * ptr, size_t size, size_t nobj, file*)
</code></pre></li>
<li><p>
<code>getc</code>
</p>

<pre><code>int getc(file*);
int fgetc(file*);
char * gets (file*)
char * fgets(char *s, int n, file *);
</code></pre>

<ul>
<li><p>
<code>fgetc</code> and <code>getc</code> are basically interchangable for our purposes.
</p></li>
<li><p>
you are getting the next character from the file.
</p></li>
<li><p>
<code>gets</code> wil read a string until a new line or an end of file.
</p>

<ul>
<li>
reading by file one line at a time.
</li>
</ul></li>
<li><p>
<code>fgets</code> will read a maximum of <code>n</code> characters or a new line, whicever ccomes first.
</p></li>
</ul></li>
<li><p>
some overlap
</p>

<pre><code>void rewing(file*);
fseek(file*, ol, seek_set);
long ftell(file*);
</code></pre></li>
<li><p>
C preprocessor
</p>

<pre><code>#include &lt;stdio.h&gt;
#include "myheader.h
</code></pre></li>
<li><p>
Macros
</p>

<pre><code>#define some_id
#define asize 100
#define max(a,b) ((a&gt;b ? a : b)
</code></pre></li>
<li><p>
conditional compilation
</p>

<pre><code>#if expression
#elif expression
#else
#endif

#ifdef some #define
#endif
#ifndef some #define
#endf
</code></pre></li>
</ul>

<h2>
February 10th, 2013 - <a href="http://www.csse.uwa.edu.au/programming/ansic-library.html#string">Notes: The ANSI C <code>string.h</code></a>
</h2>

<ul>
<li><p>
Copy ct to s including terminating <code>NUL</code>. Return s.
</p>

<pre><code>char* strcpy(char* s, const char* ct);
</code></pre></li>
<li><p>
Copy at most n characters of ct to s Pad with <code>NUL</code>s if ct is of length less than n. Return s.
</p>

<pre><code>char* strncpy(char* s, const char* ct, int n);
</code></pre></li>
<li><p>
Concatenate ct to s. Return s.
</p>

<pre><code>char* strcat(char* s, const char* ct);
</code></pre></li>
<li><p>
Concatenate at most n characters of ct to s. Terminate s with <code>NUL</code> and return it.
</p>

<pre><code>char* strncat(char* s, const char* ct, int n);
</code></pre></li>
<li><p>
Compare cs and ct. Return negative if <code>cs &lt; ct</code>, zero if <code>cs == ct</code>, positive if <code>cs &gt; ct</code>.
</p>

<pre><code>int strcmp(const char* cs, const char* ct);
</code></pre></li>
<li><p>
Compare at most n characters of cs and ct. Return negative if <code>cs &lt; ct</code>, zero if <code>cs == ct</code>, positive if <code>cs &gt; ct</code>.
</p>

<pre><code>int strncmp(const char* cs, const char* ct, int n);
</code></pre></li>
<li><p>
Return pointer to first occurrence of c in cs, or <code>NULL</code> if not found.
</p>

<pre><code>char* strchr(const char* cs, int c);
</code></pre></li>
<li><p>
Return pointer to last occurrence of c in cs, or <code>NULL</code> if not found.
</p>

<pre><code>char* strrchr(const char* cs, int c);
</code></pre></li>
<li><p>
Return length of prefix of cs consisting entirely of characters in ct.
</p>

<pre><code>size_t strspn(const char* cs, const char* ct);
</code></pre></li>
<li><p>
Return length of prefix of cs consisting entirely of characters <em>not</em> in ct.
</p>

<pre><code>size_t strcspn(const char* cs, const char* ct);
</code></pre></li>
<li><p>
Return pointer to first occurrence within cs of any character of ct, or <code>NULL</code> if not found.
</p>

<pre><code>char* strpbrk(const char* cs, const char* ct);
</code></pre></li>
<li><p>
Return pointer to first occurrence of ct in cs, or <code>NULL</code> if not found.
</p>

<pre><code>char* strstr(const char* cs, const char* ct);
</code></pre></li>
<li><p>
Return length of cs.
</p>

<pre><code>size_t strlen(const char* cs);
</code></pre></li>
<li><p>
Return pointer to implementation-defined string corresponding with error n.
</p>

<pre><code>char* strerror(int n);
</code></pre></li>
<li><p>
A sequence of calls to <code>strtok</code> returns tokens from s delimted by a character in ct. Non-<code>NULL</code> s indicates the first call in a sequence. ct may differ on each call. Returns <code>NULL</code> when no such token found.
</p>

<pre><code>char* strtok(char* s, const char* t);
</code></pre></li>
<li><p>
Copy n characters from ct to s. Return s. Does not work correctly if objects overlap.
</p>

<pre><code>void* memcpy(void* s, const void* ct, int n);
</code></pre></li>
<li><p>
Copy n characters from ct to s. Return s. Works correctly even if objects overlap.
</p>

<pre><code>void* memmove(void* s, const void* ct, int n);
</code></pre></li>
<li><p>
Compare first n characters of cs with ct. Return negative if <code>cs &lt; ct</code>, zero if <code>cs == ct</code>, positive if <code>cs &gt; ct</code>.
</p>

<pre><code>int memcmp(const void* cs, const void* ct, int n);
</code></pre></li>
<li><p>
Return pointer to first occurrence of c in first n characters of cs, or <code>NULL</code> if not found.
</p>

<pre><code>void* strchr(const char* cs, int c, int n);
</code></pre></li>
<li><p>
Replace each of the first n characters of s by c. Return s.
</p>

<pre><code>void* strchr(char* s, int c, int n);
</code></pre></li>
</ul>

<h2>
February 12th, 2013 - Recitation
</h2>

<h3>
What is GDB
</h3>

<ul>
<li>
GDB is a debugger that helps you debug your program.
</li>
<li><p>
The time you spend now learning gdb will save you days of debugging time.
</p></li>
<li><p>
A debugger will make a good programmer and better programmer.
</p></li>
</ul>

<h3>
Compiling a program for GDB
</h3>

<ul>
<li><p>
You need to compile with the <code>-g</code> option to be able to debug a program with gdb.
</p></li>
<li><p>
The <code>-g</code> option adds debugging information to your program.
</p>

<pre><code>gcc -g -o hello hello.c
</code></pre></li>
</ul>

<h3>
Running a program with GDB
</h3>

<ul>
<li><p>
To run a program with <code>gdb</code> type
</p>

<pre><code>gdb progname
(gdb)
</code></pre></li>
<li><p>
Then set a breakpoint in the main function
</p>

<pre><code>(gdb) break main
</code></pre></li>
<li><p>
A breakpoint is a marker in your program to tell the porgram to stop and return control back to <code>gdb</code>
</p></li>
</ul>

<h3>
Stepping through your program
</h3>

<ul>
<li><p>
Your porgram will start running and when it reaches <code>main()</code> it will stop.
</p>

<pre><code>gdb&gt;
</code></pre></li>
<li><p>
Now you have the folloiwing commands to run your program step by step:
</p>

<ul>
<li><p>
Run the next line of code and stop, it will enter into a function
</p>

<pre><code>gdb step
</code></pre></li>
<li><p>
Run the next line of code and stop, do not go into function
</p>

<pre><code>gdb next
</code></pre></li>
</ul></li>
</ul>

<h3>
Printing the Value of a Variable
</h3>

<ul>
<li><p>
This command prints a variable
</p>

<pre><code>(gdb) print var
</code></pre></li>
</ul>

<h2>
February 13th, 2013 - Lecture
</h2>

<h3>
Binary Numbers
</h3>

<ul>
<li>
base 2, each digit is 0 or 1
</li>
<li>
Numbers are written as \( d_n, ..., d_2, d_1, d_0 \)
</li>
<li>
Value of number is computer as \[ _{i = 0}\^n d_i 2\^i \]
</li>
</ul>

<h3>
Hexadecimal numbers
</h3>

<ul>
<li>
Base 16
</li>
<li><p>
Each digit c an be one of 16 different valyes
</p>

<ul>
<li>
Symbols = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F}
</li>
</ul></li>
<li><p>
Value \[ _{i = 0}\^n d_i 16\^i \]
</p></li>
</ul>

<h3>
Octal numbers
</h3>

<ul>
<li>
Little more awkward
</li>
<li>
Same basic idea, except power of 8
</li>
<li>
Grabbing 3 bits at a time
</li>
<li>
Value =
</li>
</ul>

<p>
\[ _{i = 0}\^n d_i 8\^i \]
</p>

<h3>
Converting hex to binary
</h3>

<ul>
<li>
Each hexademical digit can be represented by 4 binary digits
</li>
<li><p>
What is <code>0o45</code> in binary?
</p>

<ol>
<li>
0b01000101
</li>
<li>
0b100101
</li>
<li>
0b010010
</li>
</ol></li>
<li><p>
What is the general rule for conversion?
</p></li>
</ul>

<blockquote>
  <p>
Real programmers use hex
</p>
</blockquote>

<h3>
Converting binary to hex
</h3>

<ul>
<li>
Grab 4 bits at a time, change to corresponding digit in hex
</li>
<li>
Go from right to left
</li>
<li><p>
Example: <code>1011011110011100</code>
</p>

<pre><code>0b1011011110011100 = 0xb79
</code></pre></li>
</ul>

<h3>
Decimal to binary
</h3>

<ul>
<li>
What is the largest power of 2, q, r... such that \[ n = 2\^p +] where \(r_1 2\^p \) \[n - 2\^p = 2\^q + r_2\] where \(*r_2 2^q \) \[ n - (2^p + 2^q) = 2^r + r_3\] where \(r_3 &amp;lt; r^r\)
</li>
</ul>

<h3>
Decimal and binary fractions
</h3>

<ul>
<li><p>
In decimal, digits to the right of radix point have value \(\^i\) for each digit in the \(i^{th}\) place
</p>

<ul>
<li>
0.25 is 2/10 + 5/100
</li>
</ul></li>
<li><p>
Similarly, ib binary, digits to the right of radix point have value \(1/2^i\) for each ith place
</p>

<ul>
<li>
Just the base is different
</li>
</ul></li>
</ul>

<h3>
Data sizes
</h3>

<pre><code>    C           32      64
    char        1       1
    shot int    2       2
    int         4       4
    pointer     4       8
</code></pre>

<h3>
Big endian vs. small endian
</h3>

<ul>
<li><p>
How toi determine value when have a sbinary number spread across multiple bytes
</p>

<pre><code>A0 BC 00 12
</code></pre>

<ul>
<li><p>
Is this <code>A0BC0012</code> or <code>1200BCA0</code>
</p>

<ul>
<li><p>
One is called little endian and the other is called big endian
</p></li>
<li><p>
Makes no difference to computer architecture
</p></li>
</ul></li>
<li><p>
Why do we care?
</p>

<ul>
<li>
Interpret machine code and values
</li>
<li>
One computer sending data to another computer
</li>
<li>
Need to convert to standard before transmitting
</li>
</ul></li>
</ul></li>
<li><p>
<strong>Big endian</strong>: MSB first, decreasing numeric significiance as byte address increases
</p></li>
<li><p>
<strong>Little endian</strong>: LSB first, increasing numeric significane as byte address increase
</p></li>
</ul>

<h3>
Representing integers
</h3>

<ul>
<li><p>
How do we represent negative number in computers?
</p>

<ul>
<li>
You use a bit
</li>
</ul></li>
<li><p>
Signed magnitude
</p>

<pre><code>0100 = 4
0011 = 3
1100 = -4
1011 = -3
</code></pre></li>
<li><p>
Unsigned integers n bits \[0 ... 2\^n - 1\]
</p></li>
<li><p>
Signed magnitude \[ 10000*{10} = 00002710\] \[-10000*{10} =] \[-2\^{n-1} ... 2\^{n-1} \]
</p>

<pre><code>00000000 = 0
80000000 = 0
</code></pre>

<ul>
<li>
This complicated the hardware because two representaitons equal the same thing.
</li>
</ul></li>
<li><p>
The complelemtn
</p>

<pre><code>10000_{10} = 00002710
-10000 = FFFFD8EF
</code></pre></li>
<li><p>
Two's complement
</p>

<pre><code>00002710
FFFFD8EF FLIP
FFFFD8F0 ADD 1

00000000
FFFFFFFF FLIP
00000000 ADD 1
</code></pre></li>
<li><p>
You are not required to nkow these numbers
</p>

<pre><code>8 bits      -128 to +127
16 bits     -32768 to +32767
32 bits     -2147483648 to +2147483647
</code></pre></li>
<li><p>
Two's complement in n bits
</p>

<ul>
<li>
value \[-d_{n-1}2\^{n-1}]\[_{i=0}<sup>{n-1}d_is</sup>i\]
</li>
<li>
range \[ \]
</li>
</ul></li>
<li><p>
Some math
</p></li>
</ul>

<p>
\[1000*{10} = 000003E8 = \] \[0x2\^{31} + 1000*{10} = 1000 \]
</p>

<p>
\[-1000_{10} = FFFFFC18\]
</p>

<h3>
ASCII table
</h3>

<pre><code>    DEC OCT HEX BIN Symbol  HTML Number HTML Name   Description
    0   000 00  00000000    NUL &amp;#000;      Null char
    1   001 01  00000001    SOH &amp;#001;      Start of Heading
    2   002 02  00000010    STX &amp;#002;      Start of Text
    3   003 03  00000011    ETX &amp;#003;      End of Text
    4   004 04  00000100    EOT &amp;#004;      End of Transmission
    5   005 05  00000101    ENQ &amp;#005;      Enquiry
    6   006 06  00000110    ACK &amp;#006;      Acknowledgment
    7   007 07  00000111    BEL &amp;#007;      Bell
    8   010 08  00001000     BS &amp;#008;      Back Space
    9   011 09  00001001     HT &amp;#009;      Horizontal Tab
    10  012 0A  00001010     LF &amp;#010;      Line Feed
    11  013 0B  00001011     VT &amp;#011;      Vertical Tab
    12  014 0C  00001100     FF &amp;#012;      Form Feed
    13  015 0D  00001101     CR &amp;#013;      Carriage Return
    14  016 0E  00001110     SO &amp;#014;      Shift Out / X-On
    15  017 0F  00001111     SI &amp;#015;      Shift In / X-Off
    16  020 10  00010000    DLE &amp;#016;      Data Line Escape
    17  021 11  00010001    DC1 &amp;#017;      Device Control 1 (oft. XON)
    18  022 12  00010010    DC2 &amp;#018;      Device Control 2
    19  023 13  00010011    DC3 &amp;#019;      Device Control 3 (oft. XOFF)
    20  024 14  00010100    DC4 &amp;#020;      Device Control 4
    21  025 15  00010101    NAK &amp;#021;      Negative Acknowledgement
    22  026 16  00010110    SYN &amp;#022;      Synchronous Idle
    23  027 17  00010111    ETB &amp;#023;      End of Transmit Block
    24  030 18  00011000    CAN &amp;#024;      Cancel
    25  031 19  00011001     EM &amp;#025;      End of Medium
    26  032 1A  00011010    SUB &amp;#026;      Substitute
    27  033 1B  00011011    ESC &amp;#027;      Escape
    28  034 1C  00011100     FS &amp;#028;      File Separator
    29  035 1D  00011101     GS &amp;#029;      Group Separator
    30  036 1E  00011110     RS &amp;#030;      Record Separator
    31  037 1F  00011111     US &amp;#031;      Unit Separator
</code></pre>

<h3>
Code
</h3>

<pre><code>    int at01(char * s) {
        int value,mult;

        if (*s == '_') {
            mult = -1;
            ++s;
        } else if (*s == '+') {
            mult = 1;
            ++s;
        } else {
            mult = 1;
        }

        value = 0;

        while (isdigit(*s)) {
            value = 10*value + (*s - '0');
            ++s;
        }

        return mult * value;
    }
</code></pre>

<h3>
IEEE floating point standard
</h3>

<ul>
<li><p>
Most computer follow IEEE 754 standard
</p>

<ul>
<li><p>
Single precision
</p>

<ul>
<li>
32 bits
</li>
<li>
1 bit for sign, 8 bits for exponent, 23 bits for mintissa
</li>
<li>
Has two zeroes
</li>
</ul></li>
<li><p>
Double precision
</p>

<ul>
<li>
64 bits
</li>
</ul></li>
<li><p>
Extended precision
</p>

<ul>
<li>
80 bits
</li>
</ul></li>
</ul></li>
</ul>

<h2>
February 12th, 2013 - <a href="http://www.cprogramming.com/snippets/source-code/singly-linked-list-insert-remove-add-count">Singly Linked List Implementation</a>
</h2>

<pre><code>    #include&lt;stdio.h&gt;
    #include&lt;stdlib.h&gt;
     
    struct node
    {
        int data;
        struct node *next;
    }*head;
     
    void append(int num)
    {
        struct node *temp,*right;
        temp= (struct node *)malloc(sizeof(struct node));
        temp-&gt;data=num;
        right=(struct node *)head;
        while(right-&gt;next != NULL)
        right=right-&gt;next;
        right-&gt;next =temp;
        right=temp;
        right-&gt;next=NULL;
    }
     
    void add( int num )
    {
        struct node *temp;
        temp=(struct node *)malloc(sizeof(struct node));
        temp-&gt;data=num;
        if (head== NULL)
        {
        head=temp;
        head-&gt;next=NULL;
        }
        else
        {
        temp-&gt;next=head;
        head=temp;
        }
    }
    void addafter(int num, int loc)
    {
        int i;
        struct node *temp,*left,*right;
        right=head;
        for(i=1;i&lt;loc;i++)
        {
        left=right;
        right=right-&gt;next;
        }
        temp=(struct node *)malloc(sizeof(struct node));
        temp-&gt;data=num;
        left-&gt;next=temp;
        left=temp;
        left-&gt;next=right;
        return;
    }
     
    void insert(int num)
    {
        int c=0;
        struct node *temp;
        temp=head;
        if(temp==NULL)
        {
        add(num);
        }
        else
        {
        while(temp!=NULL)
        {
            if(temp-&gt;data&lt;num)
            c++;
            temp=temp-&gt;next;
        }
        if(c==0)
            add(num);
        else if(c&lt;count())
            addafter(num,++c);
        else
            append(num);
        }
    }
     
    int delete(int num)
    {
        struct node *temp, *prev;
        temp=head;
        while(temp!=NULL)
        {
        if(temp-&gt;data==num)
        {
            if(temp==head)
            {
            head=temp-&gt;next;
            free(temp);
            return 1;
            }
            else
            {
            prev-&gt;next=temp-&gt;next;
            free(temp);
            return 1;
            }
        }
        else
        {
            prev=temp;
            temp= temp-&gt;next;
        }
        }
        return 0;
    }
     
    void  display(struct node *r)
    {
        r=head;
        if(r==NULL)
        {
        return;
        }
        while(r!=NULL)
        {
        printf("%d ",r-&gt;data);
        r=r-&gt;next;
        }
        printf("\n");
    }
     
    int count()
    {
        struct node *n;
        int c=0;
        n=head;
        while(n!=NULL)
        {
        n=n-&gt;next;
        c++;
        }
        return c;
    }
     
    int  main()
    {
        int i,num;
        struct node *n;
        head=NULL;
        while(1)
        {
        printf("\nList Operations\n");
        printf("===============\n");
        printf("1.Insert\n");
        printf("2.Display\n");
        printf("3.Size\n");
        printf("4.Delete\n");
        printf("5.Exit\n");
        printf("Enter your choice : ");
        if(scanf("%d",&amp;i)&lt;=0){
            printf("Enter only an Integer\n");
            exit(0);
        } else {
            switch(i)
            {
            case 1:      printf("Enter the number to insert : ");
                     scanf("%d",&amp;num);
                     insert(num);
                     break;
            case 2:     if(head==NULL)
                    {
                    printf("List is Empty\n");
                    }
                    else
                    {
                    printf("Element(s) in the list are : ");
                    }
                    display(n);
                    break;
            case 3:     printf("Size of the list is %d\n",count());
                    break;
            case 4:     if(head==NULL)
                    printf("List is Empty\n");
                    else{
                    printf("Enter the number to delete : ");
                    scanf("%d",&amp;num);
                    if(delete(num))
                        printf("%d deleted successfully\n",num);
                    else
                        printf("%d not found in the list\n",num);
                    }
                    break;
            case 5:     return 0;
            default:    printf("Invalid option\n");
            }
        }
        }
        return 0;
    }
</code></pre>

<h2>
February 12th, 2013 - Programming Assignment 2: Data Representation and Computer Arithmetic
</h2>

<h3>
Introduction
</h3>

<p>
This assignment is designed to help you learn the representation, interpretation, and manipulation of data as bits. There are two parts. In the first part, you will implement a program calc to add and subtract numbers specified in different bases (multiplication is extra credit). In the second part, you will implement a program format that will print the decimal values of bit sequences representing integer and floating point data types.
</p>

<h3>
Numeric Base Conversion and Calculator
</h3>

<p>
Implement a program called calc with the following usage interface:
</p>

<pre><code>    calc &lt;op&gt; &lt;number1&gt; &lt;number2&gt; &lt;output base&gt;
</code></pre>

<p>
The first argument, <code>&lt;op&gt;</code>, is either the string <code>+</code>, for addition, or <code>-</code>, for subtraction. If you want to implement multiplication, then <code>&lt;op&gt;</code> can also be the string <code>*</code>. (If you do implement multiplication, make sure to say so in your readme.pdf file so that the TAs know to check your program for this functionality.) The next two arguments, <code>&lt;number1&gt;</code> and <code>&lt;number2&gt;</code> are integers of arbitrary size. Each of these numbers will be given in the form of:
</p>

<pre><code>    −?(b|o|d|x)d_n d_{n−1} ...d_1 d_0 
</code></pre>

<p>
which can be interpreted as: a number can optionally start with a <code>−</code> sign, followed by a base indicator, where <code>b</code> means the number is a binary number, <code>o</code> means octal, <code>d</code> means decimal, and <code>x</code> means hexadecimal. \(d_nd_{n−1}...d_1d_0 \) are the digits of the number.
</p>

<p>
The final argument, <code>&lt;output base&gt;</code>, gives the base that the resulting number should be printed out in. Like the base indicator for the input numbers, this argument can be one of four strings: <code>b</code> for binary, <code>o</code> for octal, <code>d</code> for decimal, and <code>h</code> for hexadecimal. Your program should output the answer in the same form as the input numbers (that is, the output number should follow the regular expression given above). Some examples:
</p>

<pre><code>    $ ./calc + d1111111111111111 d1111111111111111 d
    d222222222222222
    $ ./calc + b1101 b1 d
    d14
    $ ./calc + d999999999 d1 d
    d1000000000
    $ ./calc - d10 -d4 b
    b1110
    $ ./calc + -d10 -d4 b
    -b1110
</code></pre>

<p>
<strong>Note</strong>: The numbers in the first example are too large to fit in a 32-bit integer type in C; this is why the arbitrary size is emphasized above. Using a 64-bit integer type is not the solution since the input integers can be arbitrarily large. Rather, you need to design data structures and algorithms that can handle arbitrarily large numbers.
</p>

<p>
<strong>Assignment update</strong>: any decimal number that we ask you to handle—either an input decimal number or output in decimal format—will be less than a 32-bit integer. Important: You must write the base conversion code yourself. You may not use type-casting, libraries, or output formats in printf(). You may use standard C arithmetic operations. You may use the C standard libraries for functionality not related to the conversion (e.g., string handling functions).
</p>

<p>
<strong>Important</strong>: If calc detects an error in the inputs, it should print out an error message that starts with the string “ERROR”, followed by a string that gives an informative message about the error that it detected.
</p>

<h3>
Format Interpretation
</h3>

<p>
Implement a program called format with the following usage interface: format <code>&lt;input bit sequence&gt; &lt;type&gt;</code> The first argument, <code>&lt;input bit sequence&gt;</code>, is a sequence of 32 bits. Remember that your C program will get it as a string of 1 and 0 characters in the <code>argv[1]</code> argument to main. This sequence of bits represents the binary values stored in 4 contiguous bytes in memory. The leftmost bits are stored in the byte with the smallest address while the rightmost bits are stored in the byte with the largest address. The second argument, <code>&lt;type&gt;</code>, gives the type that you should use to interpret the input bit sequence, and can be either int (integer) or float. The formats for the input bit sequence is as follows. If the type is: int: the format is two’s complement; float: the format is IEEE 74 single precision; Note that the input bit sequence can correspond to negative numbers.
</p>

<p>
Your program should print out the decimal representation of the input bit sequence, assuming a big endian byte ordering. Floating point numbers should be printed in scientific notation, where a number 1.5x105 would be printed as 1.5e5. For positive infinity, output pinf, for negative infinity, output ninf, and for “NaN”, output NaN. Here are some examples:
</p>

<pre><code>    $ ./format 01000001010000100100001101000100 int
    1094861636
    $ ./format 10000001010000100100001101000100 int
    -2126363836
    $ ./format 01000001010000100100001110000100 int
    1094861700
    $ ./format 00000000000000000000000000000001 int
    1
    $ ./format 01000000110000110100001111010100 float
    6.10203e0
    $ ./format 00111010000111111111011000001000 float
    6.1e-4
    $ ./format 10000000000000000000000000000000 float
    -0.0e0
    $ ./format 01000000010010010000111111011011 float
    3.141593e0
</code></pre>

<p>
Important: You must write the interpretation code yourself. You may not use type-casting, libraries, or output formats in printf(). You may use standard C arithmetic operations. You may use the C standard libraries for functionality not related to the value interpretation (e.g., string handling functions). Important: If format detects an error in the inputs, it should print out an error message that starts with the string “ERROR”, followed by a string that gives an informative message about the error that it detected. For this program, you can assume that any input bit sequence that is shorter or longer than 32 bits is erroneous.
</p>

<h3>
Submission
</h3>

<p>
You have to e-submit the assignment using Sakai. Your submission should be a tar file named pa2.tar that can be extracted using the command:
</p>

<pre><code>    tar xf pa2.tar
</code></pre>

<p>
Your tar file must contain: + A sub-directory named calc. calc must contain: – readme.pdf: this file should describe your design and implementation of the calc pro- gram. In particular, it should detail your design, any design/implementation challenges that you ran into, and an analysis (e.g., big-O analysis) of the space and time perfor- mance of your program. – Makefile: there should be at least two rules in this Makefile: calc build your calc executable. clean prepare for rebuilding from scratch. – source code: all source code files necessary for building calc. At a minimum, this should include two files, calc.h and calc.c. + A sub-directory named format. format must contain: – readme.pdf: this file should describe your design and implementation for the format program. In particular, it should detail your design, any design/implementation chal- lenges that you ran into, and an analysis (e.g., big-O analysis) of the space and time performance of your program. – Makefile: there should be at least two rules in your Makefile: format build your format executable. clean prepare for rebuilding from scratch. – source code: all source code files necessary for building format. At minimum, this should include two files, format.h and format.c. We will compile and test your program on the iLab machines so you should make sure that your program compiles and runs correctly on these machines. You must compile all C code using the gcc compiler with the -ansi -pedantic -Wall flags.
</p>

<h3>
Grading Guidelines
</h3>

<h4>
Functionality
</h4>

<p>
This is a large class so that necessarily the most significant part of your grade will be based on programmatic checking of your program. That is, we will build a binary using the Makefile and source code that you submitted, and then test the binary for correct functionality against a set of inputs. Thus: + You should make sure that we can build your program by just running make. + You should test your code as thoroughly as you can. In particular, your code should be adept at handling exceptional cases. Be careful to follow all instructions. If something doesn’t seem right, ask.
</p>

<h4>
Design
</h4>

<p>
Having said the above about functionality, design is a critical part of any programming exercise. In particular, we expect you to write reasonably efficient code based on reasonably performing algorithms and data structures. More importantly, you need to understand the performance (time &amp; space) implications of the algorithms and data structures you chose to use. Thus, the explanation of your design and analyses in the readme.pdf will comprise a non-trivial part of your grade. Give careful thoughts to your writing of this file, rather than writing whatever comes to your mind in the last few minutes before the assignment is due.
</p>

<h4>
Coding Style
</h4>

<p>
Finally, it is important that you write “good” code. Unfortunately, we won’t be able to look at your code as closely as we would like to give you good feedback. Nevertheless, a part of your grade will depend on the quality of your code. Here are some guidelines for what we consider to be good: - Your code is modularized. That is, your code is split into pieces that make sense, where the pieces are neither too small nor too big. - Your code is well documented with comments. This does not mean that you should comment every line of code. Common practice is to document each function (the parameters it takes as input, the results produced, any side-effects, and the function’s functionality) and add comments in the code where it will help another programmer figure out what is going on. - You use variable names that have some meaning (rather than cryptic names like i). Further, you should observe the following protocols to make it easier for us to look at your code: - Define prototypes for all functions. - Place all prototype, typedef, and struct definitions in header (.h) files. • Error and warning messages should be printed to stderr using fprintf.
</p>

<h2>
February 13th, 2013 - Office hours
</h2>

<ul>
<li>
Exceptions are bad.
</li>
<li>
<code>strcasecmp</code> is fine.
</li>
<li>
A buffer of 128 bytes is fine.
</li>
</ul>

<h2>
February 15th, 2013 - Wordstat Readme
</h2>

<h3>
Data Structures
</h3>

<p>
The overarching design philosophy I have is object-oriented in perspective. I designed my <code>struct</code>s to behave like objects, with the following properties:
</p>

<ul>
<li><p>
Every structure is contained in its own header file.
</p></li>
<li><p>
Every structure has helper functions that handle allocating of memory.
</p></li>
<li><p>
Every structure has helper functions which “put” and “get” references.
</p></li>
</ul>

<p>
This allowed the main function to work as a <em>tour de force</em>, where nothing is defined and everything is used.
</p>

<p>
The short hand version of my implementation is: a balanced character BST of ‘a’ through ‘z’ with a nested BST of case insensitive words with a nested linked list of case sensitive word.
</p>

<h4>
<code>struct char_tree_node</code>
</h4>

<p>
This is my foundational data structure. It is a binary search tree which is loaded with character ‘a’ through ‘z’. They’re loaded in such a way that this particular tree ends up being balanced. Here’s a representation of the tree after the function <code>bld_char_tree</code> is called:
</p>

<h5>
<code>char letter</code>
</h5>

<p>
Represents the character which this node is responsible for. Every word in the subtree, defined later in this document, will begin with this character.
</p>

<h5>
char_tree_node <em>left, </em>right
</h5>

<p>
These represent the edges between two nodes, forming a tree structure.
</p>

<h5>
<code>word_tree_node *words</code>
</h5>

<p>
This points to a struct which is another nested binary search tree.
</p>

<h4>
<code>struct word_tree_node</code>
</h4>

<p>
Every character node has a word node. A word node is the principal store for information of the statistic of a document. Any given word tree is limited to words which begin with a single character, by virtue of its “parent” structure, the character tree.
</p>

<p>
In order to make processing simple, the word tree is stored in its own file with a header which defines convenience functions for allocation, insertion, and retrieval.
</p>

<h5>
<code>char *case_insensitive_word</code>
</h5>

<p>
This string stores the word that this node is representing. It is case insensitive in that it may change the case when it is inserted or it may not, but when used you should disregard any case information.
</p>

<p>
As the spec dictates, this stores any sequence of letters and digits that starts with a letter, followed by 0 or more letters and/or digits.
</p>

<h5>
<code>int total_instances</code>
</h5>

<p>
This integer is the number of time that <code>case_insensitive_word</code> has appeared in total. It is case-insensitive instances.
</p>

<p>
When outputted, this will be called “Total No. Occurrences.”
</p>

<h5>
struct word_tree_node <em>left, </em>right
</h5>

<p>
So as to create a tree structure, these pointers represent a left and right, where every sub-tree to the left contains values strictly smaller than the root, and everything to the right is strictly greater than root.
</p>

<p>
The “number” of a string is determined lexicographically.
</p>

<h5>
<code>int cases_instances</code>
</h5>

<p>
Closely linked with the <code>struct</code> defined below, this number represents the number of case-sensitive variations on the word this node represents exist in the document.
</p>

<p>
When outputted, this will be called “No. Case-Sensitive Versions.”
</p>

<h5>
struct word_list_node *case_sensitive_list
</h5>

<p>
This is a singly-linked-list which is defined below.
</p>

<h4>
<code>struct word_list_node</code>
</h4>

<p>
Every character has a node in a tree. Every character node has a tree of case-insensitive words. Every case-insensitive node has a case-sensitive singly-linked-list.
</p>

<h5>
<code>char *case_sensitive_word</code>
</h5>

<p>
A string which is case-sensitive, used to compare against when deciding if this is a new or previously discovered case instance.
</p>

<h5>
<code>struct word_list_node *next</code>
</h5>

<p>
A linked-list needs a pointer to the next element in the list.
</p>

<h3>
Big-O Analysis
</h3>

<h4>
Space complexity
</h4>

<p>
Where <em>r</em> is the number of words in a text, <em>n</em><sub>0</sub>, <em>n</em><sub>1</sub>, . . . <em>n</em><sub><em>t</em></sub> represents the set of case-insensitive words, and <em>m</em><sub>0</sub>, <em>m</em><sub>1</sub>, . . . , <em>m</em><sub><em>t</em></sub> represents the number of case-sensitive variations on each corresponding <em>t</em> word.
</p>

<ul>
<li><p>
The character tree requires 26 × 8 bytes for the characters.
</p></li>
<li><p>
Each word tree node’s case-insensitive string requires the number of bytes of each of the <em>n</em> words.
</p></li>
<li><p>
Each word list node’s case-sensitive string requires the number of bytes of each of the <em>m</em> case-sensitive variations.
</p></li>
</ul>

<p>
The “specific” space is:
</p>

<p>
<em>O</em>(∑ <sub>0</sub><sup><em>r</em></sup><em>n</em><sub><em>r</em></sub> + <em>m</em><sub><em>r</em></sub>)
</p>

<p>
The worst case is a double-nested linear time, along with every single case being unique, resulting in:
</p>

<p>
<em>O</em>(<em>n</em><sup>3</sup>)
</p>

<h4>
Time complexity
</h4>

<h5>
Worst case
</h5>

<p>
Where we count assignments and steps with <em>n</em> words:
</p>

<ul>
<li><p>
If every word in the document begins with a letter at the bottom of the character tree, there will be +4 assignments to get the character. Say every word begins with the same one.
</p></li>
<li><p>
If every word is lexicographically greater than the previous one or lexicographically less the previous one, you end up with a “linked-list.”
</p></li>
<li><p>
If every word is a unique case-variation, you have to step through the whole-linked list every time.
</p></li>
</ul>

<p>
<em>O</em>(<em>n</em><sup>3</sup>)
</p>

<h5>
Best case
</h5>

<ul>
<li><p>
Every word begins with ‘p’
</p></li>
<li><p>
The nested word tree ends up being balanced
</p></li>
<li><p>
Every case is the same
</p></li>
</ul>

<p>
This makes the runtime equal to the best case of insert on a BST. Where <em>n</em> is the number of words:
</p>

<p>
<em>O</em>(log(<em>n</em>))
</p>

<h3>
Challenges
</h3>

<h4>
Functionality
</h4>

<p>
The functionality of the program was difficult to write in that it was a totally new language for me. This was ameliorated somewhat because I have developed for iOS in Objective-C, in a version of iOS before automatic reference counting.
</p>

<p>
Admittedly, I’m still uncertain about what the proper way to both keep declarations and operations separate (as the C90 standard dictates), and still keep complex operations from being complicated one-liners.
</p>

<h4>
Coding Style and Design
</h4>

<p>
I struggled with what the best way to use C as C is. What I mean is my solution pastes onto functional programming an object-oriented mindset. I am still uncertain as to what veteran C programmers would do to solve this problem. I think that this will be lessened as the semester continues. In this one experience, however, I have come to like C more than Java. Objective-C holds a special place in my heart, however.
</p>

<h2>
February 18th, 2013 - Recitation
</h2>

<h3>
Decimal to Binary
</h3>

<pre><code>_   _   _   _   _  
2^4 2^3 2^2 2^1 2^0
</code></pre>

<h3>
Binary to Decimal
</h3>

<pre><code>1   0   0   1   0
2^4 2^3 2^2 2^1 2^0

2^4 = 16
2^1 = 2
____+___
      18
</code></pre>

<h3>
Hex to Binary
</h3>

<p>
The general algorithm is to convert each individual number into binary, and then concatenate the results.
</p>

<pre><code>2   A   8   C

2 -&gt; 0010
A -&gt; 1010
8 -&gt; 1000
C -&gt; 1100
____+____
0001001001011010
</code></pre>

<h4>
Hex alphabet values
</h4>

<pre><code>A -&gt; 10
B -&gt; 11
C -&gt; 12
D -&gt; 13 
E -&gt; 14
F -&gt; 15
</code></pre>

<h2>
February 18th, 2013 - Lecture
</h2>

<pre><code>_______
7     0

_______________
15            0

_______________________________
31                            0
</code></pre>

<ul>
<li>
The byte ordering in the real world starts with the most significiant and ends with the least significant.
</li>
</ul>

<h3>
Left shifting
</h3>

<ul>
<li>
A byte to shift on and a direction.
</li>
<li>
It can be evrything but negative.
</li>
<li>
Shfiting by zero is nothing is changing.
</li>
<li><p>
Sometimes your calcuation is dynamically shifting based on some information, which could result in zero.
</p></li>
<li><p>
If in 32 bit quantity 0 is our least significant and 31 is the most, then shifting to the left yields to the left bit being lost (?)
</p></li>
<li><p>
In C operators are <code>&lt;&lt;</code> and <code>&lt;&lt;=</code>
</p></li>
<li><p>
Shifting left n bits is exactly euivilent to mutiplying 2\^n
</p>

<ul>
<li><p>
if you want a nice way to multiply something by two, this is ideal.
</p>

<pre><code>//__ these two bits get discarded
    0000 1000 &lt;&lt; 2
    0010 0000
       //^^ these two bits get zeroes
</code></pre></li>
</ul></li>
<li><p>
If I had a 32 bit number, you'd just move the &quot;thrown out stuff&quot; into 64 bits, else you lose information.
</p></li>
<li><p>
If you shift an n bit number by n, it results in 0.
</p></li>
</ul>

<h3>
Right shift
</h3>

<h4>
Logical
</h4>

<ul>
<li>
This means our new high bits are zero, including sign.
</li>
</ul>

<h4>
Arithmetic
</h4>

<ul>
<li>
Preserves sign, if you shift a negative number, it wont discard the last bit.
</li>
</ul>

<h3>
Bitwise operations
</h3>

<ul>
<li><p>
<strong>And</strong>: C operator is <code>&amp;</code>
</p>

<pre><code>1100
1011
&amp;___
1000
</code></pre>

<ul>
<li>
This is all the posibilites for a single bit, evidently.
</li>
<li>
They both have to be one. They both have to be one.
</li>
<li>
This is comparing numbers to their respective others in the other number and returning a number which represents where they are both one, or there is at least one zero.
</li>
</ul></li>
<li><p>
<strong>Or</strong>: C operator is <code>|</code>
</p>

<pre><code>1100
1010
|___
1110
</code></pre>

<ul>
<li>
Just like the last operation, but the result is or.
</li>
<li>
This means only and at least on of the bits must be one for the final bit to be one.
</li>
</ul></li>
<li><p>
Exclusive or: C operator is <code>^</code>
</p>

<pre><code>    1100
^ 1010
______
  0110
</code></pre></li>
<li><p>
<strong>Not</strong> C operator is <code>~</code>
</p>

<pre><code>~10
 01
</code></pre></li>
</ul>

<h3>
DeMorgan's Law
</h3>

<pre><code>    A || B = !(!A &amp;&amp; !B)
    A &amp;&amp; V = !(!A || !B)
</code></pre>

<h3>
Using two's complement
</h3>

<ul>
<li><p>
Do x and y have the same sign?
</p>

<pre><code>(x^y) &lt; 0
</code></pre></li>
</ul>

<h3>
Swapping fixed-point x and y
</h3>

<pre><code>    x ^= y
    y ^= x
    x ^= y
</code></pre>

<h3>
Rotation
</h3>

<pre><code>    unsigned int rshift (unisgned int val, unisgned int n) {
        unisgned int intsize = sizeof(int)*8;

        if (n == 0)
            return;
        else {
            return value &gt;&gt; n | value &lt;&lt; (intsize - n);
        }
    }
</code></pre>

<h2>
February 20th, 2013 - Lecture
</h2>

<ul>
<li><p>
CPU
</p>

<ul>
<li>
ALU
</li>
<li>
Control logic
</li>
<li>
PC (Instruction Pointer)
</li>
<li>
Registers
</li>
<li>
Condition Codes
</li>
</ul></li>
<li><p>
Memory
</p>

<ul>
<li>
OS code and data
</li>
<li>
Object code
</li>
<li>
Program data
</li>
</ul></li>
</ul>

<h3>
Memory
</h3>

<ul>
<li><p>
I've got these buses which I communicate addresses through from the CPU to the memory.
</p></li>
<li><p>
&quot;Go to address 3 and read&quot;
</p></li>
<li>
Go to address 4 and write.
</li>
</ul>

<h3>
Processes: ALU and Registers
</h3>

<ul>
<li>
There are functions on operarnds A nd B
</li>
</ul>

<h3>
Why do we need registers?
</h3>

<ul>
<li>
(iCQ): The register file looks just like a mini-memory
</li>
</ul>

<h3>
Basic CPU function
</h3>

<ol>
<li>
Fetch[PC++]
</li>
<li>
Decode
</li>
<li>
Execute
</li>
<li>
See 1.
</li>
</ol>

<h3>
Assembly characteristics
</h3>

<ul>
<li><p>
Minimal data types
</p>

<ul>
<li><p>
Integer data of 1, 2, or 4 bytes
</p>

<ul>
<li>
Data values
</li>
<li>
Addresses
</li>
</ul></li>
<li><p>
Floating point data of 4, 8, or 10 bytes
</p></li>
<li>
<p>No aggregate types such as arrays or structures</p>
<ul>
<li>
Just continuosly allocated bytes in memory.
</li>
</ul></li>
</ul></li>
<li><p>
No type checking
</p>

<ul>
<li>
Interpretation of data format depends on instruction
</li>
<li>
No protection against misinterpretation of data
</li>
</ul></li>
<li><p>
There's the idea of a process
</p>

<ul>
<li>
Every program is running in its own virtual address space
</li>
<li>
If I do something and I can read only the stuff on my process
</li>
</ul></li>
<li><p>
Primitive operationnnnnns
</p>

<ul>
<li>
Perform arithmattttic function or memory data
</li>
<li>
<p>Transfer data between memory and regggister</p>
<ul>
<li>
Load data from memory into register
</li>
</ul></li>
</ul></li>
</ul>

<h3>
x86 Characteristic
</h3>

<ul>
<li>
Variable length between 1 and 15 bytes
</li>
<li>
Can address memory directly in most instructions
</li>
<li>
Uses little endian format
</li>
</ul>

<h3>
<code>MOV</code> instruction
</h3>

<ul>
<li><p>
Most common instruction is data transfer instruction
</p>

<ul>
<li>
<p><code>mov s, d</code></p>
<ul>
<li>
Copy value at S to D
</li>
</ul></li>
</ul></li>
<li><p>
Used to copy data from:
</p>

<ul>
<li>
Memory to register
</li>
<li>
Register to memory
</li>
<li>
Register to register
</li>
<li>
Constant to register
</li>
<li>
Constant to memory
</li>
</ul></li>
<li><p>
Registers
</p>

<pre><code>                 +-----------------------------+
                 | 32 bit| 16 bit    |   8 bit |
                 +-------+-----------+---------+
                 | %eax |   %ax     |   %ah   |
                 | %ebx |   %bx     |   %bh   |
                 | %ecx |   %cx     |   %ch   |
                 | %edx |   %dx     |   %dh   |
                 | %ebp |   %bp     |   %ac   |
points to stack-&gt;| %esp |   %sp     |   %bc   |
program counter-&gt;| %eip |   %ip     |   %cc   |
seg addressing -&gt;| %esi |   %si     |   %dl   |
                 +-------+-----------+---------+

     +-----------------------------------+
     |                    +-------------+|
%eax |                 %ax|%ah   |  %al || 
     |                    +-------------+|
     +-----------------------------------+
     31                   15             0
</code></pre></li>
</ul>

<h3>
A little bit about the stack
</h3>

<ul>
<li><p>
I am pushing and popping individual values on this stack, a word byte
</p></li>
<li><p>
Double word, quad work.
</p></li>
<li>
1, 2, 4 eight byte values.
</li>
<li><p>
From the stack I can build a call stack, indivudal values for all I need for a particular function invocation.
</p></li>
<li><p>
&quot;Call brain&quot; or &quot;activation brain&quot;
</p></li>
<li><p>
With the intel arch, a few things to take away:
</p>

<ul>
<li>
Grow towards smaller addresses
</li>
<li>
<code>%esp</code> always points to the top
</li>
<li><p>
When we push to the stack, we do it in two steps:
</p>

<ol>
<li>
Decrement <code>%esp</code> register by 4, has an address in it.
</li>
<li>
Copy whatever operand to wherever the <code>%esp</code> pointer points.
</li>
</ol></li>
<li><p>
Pop
</p>

<ol>
<li>
Copy that value, wherever you're going to take it.
</li>
<li>
Add 4 to <code>%esp</code>
</li>
</ol></li>
</ul></li>
</ul>

<h3>
Instructions
</h3>

<ul>
<li>
An assembly program is just an ASCII file.
</li>
<li>
You make it in text editors.
</li>
<li>
An assembly program is a sequence of assembly instructions.
</li>
<li><p>
The general form of the assembly instruction is the neumonic which is intented, and then operands.
</p></li>
<li><p>
The neumonic defines the operation.
</p></li>
<li>
There may be zero or more operands depending on the operation.
</li>
<li>
Multiple operands are seperated by commas.
</li>
<li><p>
Instructions:
</p>

<pre><code>movb    movsbw    movzbw
movw    movsbl    movzbl
movl    movswl    movswl
movq    movswq    movswq
        movslq    movslq
</code></pre></li>
</ul>

<h2>
February 26th, 2013 - Recitation
</h2>

<h3>
Binary number to floating point numbers
</h3>

<ul>
<li>
Lets assume we have 0.625 in the decimal system.
</li>
<li><p>
We use a linear array
</p>

<pre><code> __    __    __     __    __    __
|  |  |  |  |  |   |  |  |  |  |  |
|__|  |__|  |__| . |__|  |__|  |__|
2^3   2^1   2^0    2^-1  2^-2  2^-3
</code></pre></li>
</ul>

<h2>
February 26th, 2013 - Lecture: Assembly Language Programming
</h2>

<blockquote>
  <p>
How are you? <cite>Student</cite> Not dead yet. <cite>Brian Russel</cite>
</p>
</blockquote>

<h3>
Indexed Mode Addressing
</h3>

<ul>
<li><p>
Add content of two registers to get address of operand
</p>

<pre><code>movl (%eab, %esi), %eax
// Copy value at address = eab + esi into eax
movl 8(%eab, %esi), %eax
// Copy value at address = 8 + eab + esi into eax
</code></pre></li>
<li><p>
Useful for dealing with arrays
</p></li>
<li>
Autovariables and formal parameters are treated pretty much the same.
</li>
</ul>

<h3>
Address Computation Examples
</h3>

<pre><code>    %edx   0xf0000
    %ecx   0x100

    Expression    Computation      Adress
    0x8 (%edx)    0xf0000 + 0x8    0xf008
</code></pre>

<h2>
February 28th, 2013 - Lecture
</h2>

<h3>
Some Arithmetic Operations
</h3>

<pre><code>Instruction      Computation
adll  Src,Dest   Dest = Dest +  Src
subl  Src,Dest   Dest = Dest -  Src
imull Src,Dest   Dest = Dest *  Src
sall  src,Dest   Dest = Dest &lt;&lt; Src (left shift)

sarl  Src,Dest   Dest = Dest &gt;&gt; Src (right shift)
xorl  Src,Dest   Dest = Dest ^  Src
andl  Src,Dest   Dest = Dest &amp;  Src
orl   Src,Dest   Dest = Dest |  Src
</code></pre>

<h2>
March 1st, 2013 - Notes: <a href="http://en.wikipedia.org/wiki/Single-precision_floating-point_format#IEEE_754_single-precision_binary_floating-point_format:_binary32">IEEE 754</a>
</h2>

<pre><code>    sign           exponent (8 bits)            fraction (23 bits)
    +--+    +--++--++--++--++--++--++--++--+    +--+          +--+
    |01|    |02||03||04||05||06||07||08||09|    |10|    ...   |23|
    +--+    +--++--++--++--++--++--++--++--+    +--+          +--+
</code></pre>

<p>
( − 1)<sup>sign</sup> ×  (1 + ∑ <sub><em>i</em> = 1</sub><sup>23</sup><em>b</em><sub>23 − <em>i</em></sub>2<sup> − <em>i</em></sup>)  × 2<sup>(<em>e</em> − 127)</sup>
</p>

<h2>
March 5th, 2013 - Lecture
</h2>

<ul>
<li><p>
Flags
</p>

<pre><code>cf  carry
zf  zero
sf  sign
of  overflow
</code></pre></li>
<li><p>
You can think of the compare as a &quot;non destrutive subtraction.&quot;
</p>

<pre><code>cmp  [b w l q] src,dst
test [b w l w] src,dst
</code></pre></li>
<li><p>
These, evidently, are not very interesting bu we need to know them anyway.
</p></li>
<li><p>
A column of &quot;conditional jumps&quot; to some target, the target being some lable we can specify in the program.
</p>

<pre><code>==          je
!=          jne
signed &gt;    jg
unsigned &gt;  ja
signed &lt;    jl
unsigned &lt;  jb
signed &lt;=   jle
unsigned &lt;= jbe
</code></pre></li>
<li><p>
Negatives
</p>

<pre><code>negative?       js
not negative?   jns
</code></pre></li>
<li><p>
Jumps
</p>

<ul>
<li><p>
Direct
</p>

<pre><code>jmp .l37 (?)
</code></pre></li>
</ul></li>
<li><p>
if-else
</p>

<pre><code>movl    12(%ebp),%edx
cmp     $3,%edx
jne     elsepart
.
.
.
jmp     done
elsepart:
.
.
.
done
</code></pre></li>
<li><p>
more code
</p>

<pre><code>movl    12(%ebp),%edx
test    8(%ebp), %edx
jz      elsez
.
.
.
jmp     donez
</code></pre></li>
<li><p>
for loop
</p>

<pre><code>top:
    movl    $i, %eax
    jge     done
    .           -+
    .            | body of loop
    .           -+
    inc     %eax
    jmp     top
done:
</code></pre></li>
<li><p>
condition flags
</p>

<pre><code>==          zf
!=          ~zf
signed &gt;    ~(sf^of)&amp;~zf
unsigned &gt;  ~cf &amp; ~zf
signed &gt;=   ~(sf^of)
unsigned &lt;= ~cf
signed &lt;    sf^of
unsigned &lt;  cf
</code></pre></li>
</ul>

<h2>
March 8th, 2013 - Calc and Format Readme
</h2>

<h3>
Calc
</h3>

<h4>
Design and Implementation
</h4>

<ul>
<li>
My design uses a string as the primary data structure.
</li>
<li><p>
When numbers are inputted, no matter what the are, they go through this process:
</p>

<ol>
<li>
Parse their &quot;metadata&quot; - length, are the negative, base;
</li>
<li><p>
Send their string to the relevant helper function to conversion, which convert it to binary;
</p></li>
<li><p>
Decide based on metadata how to add or use two's complement subtraction;
</p></li>
<li><p>
Based on the requested output format, send the string to the relevant helper function for conversion;
</p></li>
<li><p>
Print.
</p></li>
</ol></li>
<li><p>
I picked this because I believe that linked list are too difficult to traverse, data types have to little room (and are against spec), and it isn't really sensible to talk about hash tables or trees in this context.
</p></li>
<li><p>
My alogrithm can handle arbintraily large hex, octal, and binary input and output.
</p></li>
<li><p>
This ended up being a good method for binary, octal, and hexadecimal addition and manipulation, but very poor for decimal.
</p>

<ul>
<li>
The decimal input and output is limited to 128 bytes, as a <code>long double</code> is used.
</li>
</ul></li>
</ul>

<h4>
Challenges
</h4>

<ul>
<li><p>
Time became a huge concern. I wrote one implementation using integers after that was given the okay, but having learned that this would not receive full credit I set about on the more ambitious route.
</p>

<ul>
<li><p>
Ultimate I think this will lower my grade, but I learned enough along the way to justify the expense.
</p></li>
<li><p>
I think this is a good investment because it will serve me better in the future and on exams.
</p></li>
<li><p>
I did not get <code>format</code> done for this reason.
</p></li>
</ul></li>
<li><p>
Decimal is a terrible number system for computers, or at very least how computers operate presently.
</p>

<ul>
<li>
I could not find an algorith to go to or from binary and decimal that could handle arbitrily large input.
</li>
</ul></li>
</ul>

<h4>
Analysis
</h4>

<h5>
Space
</h5>

<ul>
<li>
The space is linearly related to the input.
</li>
<li><p>
The only space that is allocated is for three strings: input one, input two, and output.
</p></li>
<li><p>
The results in a space complexity 2<em>n</em> in the worst case, if input makes for a long binary string.
</p></li>
</ul>

<p>
<em>O</em>(<em>n</em>)
</p>

<h5>
Time
</h5>

<ul>
<li>
Small and linear operations are performed while processing.
</li>
<li>
<p>Parsing as an activity rarely leads to anything other than linear.</p>
<ul>
<li>
In processing, there are no nested for loops or anything that would make it exponential, quadratic.
</li>
</ul></li>
</ul>

<p>
<em>O</em>(<em>n</em>)
</p>

<h4>
Test cases
</h4>

<h5>
Conversions to binary
</h5>

<p>
Conversions to binary have been flawless in every tested case. The family of functions which do the conversion are rigorous and basic. My internal representation of <em>every</em> number is a binary string, so these functions are core to my functionality.
</p>

<pre><code>char * oct_to_bin (char * oct);
char * dec_to_bin (char * dec);
char * hex_to_bin (char * hex);
</code></pre>

<p>
Now for some examples!
</p>

<h6>
Binary
</h6>

<pre><code>Inputted    111111111111111111111111111111111
Expected    111111111111111111111111111111111
Actually    111111111111111111111111111111111

Note: MAX_INT
</code></pre>

<p>
Binary is successful 100% of the time because I'm being fed a binary string representation and my internal representation is a string. Granted that the computer does not run out of memory and I parsed my input correctly, this will never, ever break.
</p>

<h6>
Octal
</h6>

<pre><code>Inputted    7654321
Expected    111110101100011010001
Actually    111110101100011010001
</code></pre>

<p>
The conversion algorithm that I used to convert octal to my internal binary string representation is &quot;grabbing&quot; 1 binary bit at a time in input and 3 bits at a time on output.
</p>

<p>
This approach has yielded a 100% success rate so far.
</p>

<h6>
Decimal
</h6>

<pre><code>Inputted    987654321
Expected    111010110111100110100010110001
Actually    111010110111100110100010110001
</code></pre>

<p>
While this superficially seems to work, it has a dark secret. It uses <code>atoi</code> and an <code>int</code> to do the conversion. As with output, I could not find or invent an algorithm to consistently convert decimal to binary or the other way around.
</p>

<p>
If decimal is selected as an option on either input or output, then arbitrarily large numbers are not possible.
</p>

<h6>
Hexademical
</h6>

<pre><code>Inputted    FEDCBA987654321
Expected    111111101101110010111010100110000111011001010100001100100001
Actually    111111101101110010111010100110000111011001010100001100100001

Note: more that 32 bit
</code></pre>

<p>
Hexadecimal is performed the same as octal, for both input and output, except I &quot;grab&quot; 4 bits at a time on output.
</p>

<h5>
Addition
</h5>

<ul>
<li><p>
When both are not negative and you're adding, I add the values and display it
</p>

<pre><code>./calc + d10 d10 d
-d20
</code></pre></li>
<li><p>
Neither are negative and you're adding, so I add and do not display as negative.
</p>

<pre><code>./calc + -d200 -d200 d
-d400
</code></pre></li>
<li><p>
Number one is negative
</p>

<ul>
<li><p>
Neither number has a greater absolute value
</p>

<pre><code>./calc + -h999 h999 d
d0
</code></pre></li>
<li><p>
The first number has a greater absolute value
</p>

<pre><code>./calc + -d1000 d125 d
-d875
</code></pre></li>
<li><p>
The second number has a greater absolute value
</p>

<pre><code>./calc + -d1000 d1250 d
d250
</code></pre></li>
</ul></li>
<li><p>
Number two is negative
</p>

<ul>
<li><p>
Neither number has a greater absolute value
</p>

<pre><code>./calc + o765 -o765 h
h0
</code></pre></li>
<li><p>
The first number has a greater absolute value
</p>

<pre><code>./calc + d1350 -d1250 d
d100
</code></pre></li>
<li><p>
The second number has a greater absolute value
</p>

<pre><code> ./calc + d1000 -d1250 d
-d250
</code></pre></li>
</ul></li>
</ul>

<h5>
Subtraction
</h5>

<ul>
<li><p>
Both numbers are negative
</p>

<ul>
<li><p>
but neither number has a greater absolute value, so zero
</p>

<pre><code>./calc - -h1250 -h1250 o
o0
</code></pre></li>
<li><p>
and the first has a greater absolute value to the first
</p>

<pre><code>./calc - -d1250 -d100 d
-d1150
</code></pre></li>
<li><p>
The second has a greater absolute value to the first
</p>

<pre><code>./calc - -d1250 -d10000 d
d8750
</code></pre></li>
</ul></li>
</ul>

<h5>
Binary
</h5>

<pre><code>Inputted    ./calc + d1111111 d1111111 b
Expected    b1000011110100010001110
Actually    b1000011110100010001110
</code></pre>

<h5>
Octal
</h5>

<pre><code>Inputted    ./calc + d1111111 d1111111 o
Expected    o10364216
Actually    o10364216
</code></pre>

<h5>
Hexadecimal
</h5>

<pre><code>Inputted    ./calc + hFFFFFFFFFFFFFFFFFFFF hFFFFFFFFFFFFFFFFFFFF h
Expected    h1FFFFFFFFFFFFFFFFFFFE
Actually    h1FFFFFFFFFFFFFFFFFFFE
</code></pre>

<h3>
Format
</h3>

<h4>
Design and Implementation
</h4>

<ul>
<li><p>
Very basic, I take ints and mask them into an int, and then form a string from that int for output.
</p></li>
<li><p>
Format float does not work.
</p></li>
</ul>

<h4>
Challenges
</h4>

<ul>
<li>
Time was a massive concern.
</li>
</ul>

<h4>
Analysis
</h4>

<h5>
Space
</h5>

<p>
<em>O</em>(<em>c</em>)
</p>

<h5>
Time
</h5>

<p>
<em>O</em>(<em>c</em>)
</p>

<h2>
March 12th, 2013 - Lecture
</h2>

<h3>
Topics
</h3>

<ul>
<li>
IA32 stack disciple
</li>
<li>
Register saving conventions
</li>
<li>
Creating pointers to local variables
</li>
</ul>

<h3>
Push instructions
</h3>

<ul>
<li><p>
16 bits
</p>

<pre><code>pushw   reg16   %esp-=2 %reg16-&gt;(%esp)
pushl   mem16   %esp-=2 %reg16-&gt;(%esp)
pushl   imm16   %esp-=2 %imm16-&gt;(%esp)
</code></pre></li>
<li><p>
32 bits
</p>

<pre><code>pushw   reg32   %esp-=4 %reg32-&gt;(%esp)
pushl   mem32   %esp-=4 %reg32-&gt;(%esp)
pushl   imm32   %esp-=4 %imm32-&gt;(%esp)
</code></pre></li>
<li><p>
64 bits (quad words)
</p>

<pre><code>pushw   reg32   %esp-=4 %reg32-&gt;(%esp)
pushl   mem32   %esp-=4 %reg32-&gt;(%esp)
pushl   imm32   %esp-=4 %imm32-&gt;(%esp)   
</code></pre></li>
</ul>

<h3>
Pop instructions
</h3>

<ul>
<li><p>
16 bits
</p>

<pre><code>popw    reg16   (%esp)-&gt;reg16,  %esp+=2 
popw    mem16   (%esp)-&gt;mem16,  %esp+=2
</code></pre></li>
<li><p>
32 bits
</p>

<pre><code>popl    reg32   (%esp)-&gt;reg32,  %esp+=4 
popl    mem32   (%esp)-&gt;mem32,  %esp+=4
</code></pre></li>
<li><p>
64 bits
</p>

<pre><code>popq    reg64   (%esp)-&gt;reg64,  %esp+=8
popq    mem64   (%esp)-&gt;mem64,  %esp+=8
</code></pre></li>
</ul>

<h3>
Discussion
</h3>

<ul>
<li>
If you push your bytes, pop your bytes.
</li>
<li><p>
The call stack frames, or activation records.
</p>

<ul>
<li>
Each stack frame corresponds to each function call in C.
</li>
<li><p>
The stack frame contains space for formal parameters and automatic variables.
</p>

<ul>
<li>
If I have a recursive function, every formal parameter gets a seperate space with a seperate activation record.
</li>
</ul></li>
<li><p>
We are not limited to 2, 4, 8 bytes.
</p></li>
<li>
Each stack frame needs a return address.
</li>
<li>
The way to resume execution when we're done with the call.
</li>
<li>
The same way we use the <code>%esp</code> register to point to the top of the stack, we use the <code>%ebp</code> call frame to point to the most recently called stack frame.
</li>
</ul></li>
</ul>

<h3>
Call instructions
</h3>

<pre><code>    call    label       direct
    call    *operand    indirect
</code></pre>

<ul>
<li><p>
The first call just has a label as an operand, we call this a direct call
</p>

<ul>
<li>
Hard-coded
</li>
</ul></li>
<li><p>
The indirect call can specify a memory location or a register.
</p>

<ul>
<li>
Goes to the place and pulls the traget location and transfers control there.
</li>
</ul></li>
</ul>

<h3>
Variables
</h3>

<pre><code>    pushl   %ebp
    movel   %esp, %ebp
    .
    .
    .
    movl    %ebp, %esp
    popl    %ebp
    ret
</code></pre>

<h3>
Vertical picture
</h3>

<pre><code>            |                 |
            |Local autos      |
            |Formal parameters|
            +-----------------+
      %ebp-&gt;|old %ebp         |
            +-----------------+
            |return address   |
            +-----------------+
                     .
                     .
                     .
            +-----------------+
            |old %ebp         |
            +-----------------+
            |return address   |
            +-----------------+
</code></pre>

<h2>
March 5th, 2013 - Programming Assignment 3: Assembly Language Programming
</h2>

<h3>
Introduction
</h3>

<p>
This assignment is designed to give you additional practice in reading and writing Assembly Lan- guage programs. As discussed in lecture, unless you are working in increasingly rare areas such as low-level OS development, you are unlikely to be reading and/or writing Assembly Language pro- grams in the remainder of your career. However, we are still requiring you to read and write some here to make sure you understand the computing model underlying your C and Java programs. In addition, being able to read Assembly Language is particularly important because there are times when you need to understand what the compiler is doing to your code. There are two parts. In the first part, you will write two small functions in Assembly. In the second part, you will be deciphering (that is, write equivalent C code) an Assembly Language program, much like you have done in your homework and the Midterm Exam. You will also be asked to compare unoptimized and optimized versions of the code and explained what the compiler did when it optimized the code. Important: On most of the iLab machines that we checked, e.g., several of the Design Pattern machines, including adapter.rutgers.edu, command.rutgers.edu, and factory.rutgers.edu, gcc by de- fault will generate x86 Assembly, which is what we want. Do be careful and check the generated assembly, though, in case some of the machines are 64-bit processors, with gcc configured to gen- erate x86-64 code. If you see Assembly code with registers beginning with %r (e.g., %rbx or %r9), then it is x86-64 and not what you want. Move to another iLab machine.
</p>

<h3>
Writing x86 Assembly
</h3>

<p>
In this part, you will implement a program formula that will print the formula for (1 + x)n. In particular, your program formula should support the following usage interface:
</p>

<pre><code>formula &lt;power&gt;
</code></pre>

<p>
where the argument <code>&lt;power&gt;</code> should be a non-negative integer. Your program should print out the &quot;long&quot; form of (1 + <em>x</em>)<em>n</em>, where <em>n</em> is equal to the argument <code>&lt;power&gt;</code>. Your program should also print out its execution time (in microseconds). For example:
</p>

<pre><code>./formula 5
(1+x)^5 =1 +5*x^1+10*x^2+10*x^3+5*x^4+1*x^5 
Time Required = 50 microsecond

./formula 10
1 + x)^10  = 1 + 10*x^1 + 45*x^2 + 120*x^3 + 210*x^4 + 252*x^5
          + 210*x^6 + 120*x^7 + 45*x^8 + 10*x^9 + 1*x^10
Time Required = 55 microsecond
</code></pre>

<p>
(Hint: You can use the system call <code>gettimeofday()</code> to measure the running time of a chunk of code.) More generally, given the argument n, your code needs to generate:
</p>

<p>
(1 + <em>x</em>)<sup><em>n</em></sup> = 1 + <em>n<strong>C<em>1 * <em>x</em> + </em>n</strong>C</em>2 * <em>x</em><sup>2</sup> + . . .  + <em>n<strong>C</strong>r</em> * <em>x</em><sup><em>r</em></sup> + . . .  + <em>n<strong>C</strong>n</em> * <em>x</em><sup><em>n</em></sup>
</p>

<p>
Your program should also print a usage message if the user runs formula with the help flag (-h). For example:
</p>

<pre><code> $ ./formula -h
 Usage: formula &lt;positive integer&gt;
</code></pre>

<h3>
nCr Calculation
</h3>

<p>
Hopefully, you remember from one of your Math classes that each of the constant nCr above can be computed using the formula: \$nCr = n! \frac{r!}{(n − r)!}\$ Your task is to implement this computation in Assembly. In particular, you need to implement two functions in Assembly:
</p>

<p>
<code>int nCr(int n, int r)</code>: This function computes the nCr constant according to Equation (1).
</p>

<p>
<code>int Factorial(int n)</code>: This function computes the factorial of the input (that is, n!).
</p>

<p>
To help you get started, we are providing two files:
</p>

<p>
<code>nCr.s</code>: contains the necessary GAS (Gnu ASsembler) directives so that your Assembly code can be compiled and linked in with your C code (in format.c).
</p>

<p>
<code>nCr.h</code>: contains the prototype for the function nCr() so that you can compile your C code which calls <code>nCr()</code>.
</p>

<p>
<strong>Important</strong>: As n becomes large, you will not be able to compute n! and nCr. Both nCr() and Factorial() must detect overflow conditions using the processor’s condition codes and return 0 to indicate that an error has been encountered.
</p>

<h3>
Reading x86 Assembly Code
</h3>

<p>
In this part, you are asked to decipher the Assembly Language program in the attached mystery.s file. Specifically, you need to provide a concise description of what the program does and how it does it. You should also implement a C program mystery that performs the same task in the same manner that the code in the attached file mystery.s does. The provided program takes a single integer as input.
</p>

<pre><code> $ gcc -o mystery mystery.s
 $ ./mystery 41
 Value: 165580141
</code></pre>

<p>
<strong>Hint</strong>: This program performs a well known and easily recognizable computation. However, it includes an optimization to speedup the computation. You need to figure out both the basic functionality as well as the optimization, describe them, and replicate them in your C code. Another Hint: You are not strictly required to go backward from the mystery.s file that we give you. That is, when you start writing your mystery.c program, you can compile it to Assembly (gcc -S), and compare the generated code against our mystery.s. Our mystery.s was generated on factory.rutgers.edu so you should be able to generate the exact same code. Once you have implemented your C program, you should compile it with and without the -O option (optimization). You should then compare the two versions and explain the differences inside the mystery function.
</p>

<p>
For example:
</p>

<pre><code>\$ gcc -S mystery.c 
\$ mv mystery.s mystery.unoptimized.s
\$ gcc -S -O mystery.c 
\$ diff --side-by-side mystery.unoptimized.s
mystery.s
</code></pre>

<p>
The last command in the above sequence will show you the differences between the two .s files side by side (use a large terminal window). You should look at the differences inside the mystery function and explain why the compiler made the changes that it did when optimizing the code. Collaboration: Please do not share your solution with your classmates as this gives the problem away. You may help each other with understanding Assembly details but not the solution.
</p>

<h3>
Submission
</h3>

<p>
You have to e-submit the assignment using Sakai. Your submission should be a tar file named pa3.tar that can be extracted using the command: Your tar file must contain: tar xf pa3.tar
</p>

<ul>
<li>
A sub-directory named formula. formula must contain:
</li>
<li><p>
readme.pdf: this file should describe your design and implementation of the formula program. In particular, it should detail your design, any design/implementation chal- lenges that you ran into, and an analysis (e.g., big-O analysis) of the space and time performance of your program.
</p></li>
<li><p>
Makefile: there should be at least two rules in this Makefile: formula build your formula executable. clean prepare for rebuilding from scratch.
</p></li>
<li><p>
source code: all source code files necessary for building formula. At a minimum, this should include four files, formula.h, formula.c, nCr.s, and nCr.h. - A sub-directory named mystery. mystery must contain:
</p></li>
<li><p>
readme.pdf: this file should describe how you went about figuring out what the mystery program does. It also should describe the changes that the compiler made when opti- mizing your C code and why you think that the compiler made those changes. (That is, why might the changes make your program run faster?)
</p></li>
<li><p>
Makefile: there should be at least two rules in your Makefile: mystery build your mystery executable. clean prepare for rebuilding from scratch.
</p></li>
<li><p>
source code: all source code files necessary for building mystery. At minimum, this should include two files, mystery.h and mystery.c. We will compile and test your programs on the iLab machines so you should make sure that your programs compile and run correctly on these machines. You must compile all C code using the gcc compiler with the <code>-ansi -pedantic -Wall</code> flags.
</p></li>
</ul>

<h3>
Grading Guidelines
</h3>

<h4>
Functionality
</h4>

<p>
This is a large class so that necessarily the most significant part of your grade will be based on programmatic checking of your program. That is, we will build a binary using the Makefile and source code that you submitted, and then test the binary for correct functionality against a set of inputs. Thus: - You should make sure that we can build your program by just running make. - You should test your code as thoroughly as you can. In particular, your code should be adept at handling exceptional cases. Be careful to follow all instructions. If something doesn’t seem right, ask.
</p>

<h4>
Design
</h4>

<p>
Having said the above about functionality, design is a critical part of any programming exercise. In particular, we expect you to write reasonably efficient code based on reasonably performing algorithms and data structures. More importantly, you need to understand the performance (time &amp; space) implications of the algorithms and data structures you chose to use. Thus, the explanation of your design and analyses in the readme.pdf will comprise a non-trivial part of your grade. Give careful thoughts to your writing of this file, rather than writing whatever comes to your mind in the last few minutes before the assignment is due.
</p>

<h4>
Coding Style
</h4>

<p>
Finally, it is important that you write &quot;good&quot; code. Unfortunately, we won’t be able to look at your code as closely as we would like to give you good feedback. Nevertheless, a part of your grade will depend on the quality of your code. Here are some guidelines for what we consider to be good:
</p>

<ul>
<li><p>
Your code is modularized. That is, your code is split into pieces that make sense, where the pieces are neither too small nor too big.
</p></li>
<li><p>
Your code is well documented with comments. This does not mean that you should comment every line of code. Common practice is to document each function (the parameters it takes as input, the results produced, any side-effects, and the function’s functionality) and add comments in the code where it will help another programmer figure out what is going on.
</p></li>
<li><p>
You use variable names that have some meaning (rather than cryptic names like i). Further, you should observe the following protocols to make it easier for us to look at your code: - Define prototypes for all functions. - Place all prototype, typedef, and struct definitions in header (.h) files. - Error and warning messages should be printed to stderr using fprintf.
</p></li>
</ul>

<h2>
March 27th, 2013 - Midterm Study Guide <small>with special thanks to Matthew Resch</small>
</h2>

<h3>
Number conversion
</h3>

<h4>
Methods
</h4>

<ol>
<li><p>
Expansion
</p>

<ul>
<li><p>
To convert a number, such as binary number, to decimal, use the definition of a number representation as an abbreviated polynomial.
</p>

<p>
10101. 1 = 1<em>x</em>2<sup>4</sup> + 0<em>x</em>2<sup>3</sup> + 1<em>x</em>2<sup>2</sup> + 0<em>x</em>2<sup>1</sup> + 1<em>x</em>2<sup>0</sup> + 1<em>x</em>2<sup> − 1</sup> 16 + 0 + 4 + 0 + 1 + . 5 = 21. 5
</p></li>
</ul></li>
<li><p>
Division Method
</p>

<ul>
<li><p>
To convert a number from one base to another, take the number, divide it by the target base, keep the remainder and divide the quotient by the base until the quotient that remains is zero. Number generated from right/left.
</p></li>
<li><p>
Example: 13%2 = 1 6%2 = 0 3%2 = 1 1%2 = 1
</p></li>
</ul></li>
<li><p>
Multiplication Method
</p>

<ul>
<li>
This method is generally used to convert fractions
</li>
<li><p>
Multiply the number by the base, and keep the digit that is generated, then multiply the thing to the right of the decimal by the base again, until you have nothing to the right of the decimal.
</p></li>
<li><p>
Ex: . 7812510 → . 110012 . 78125<em>x</em>2 = 1. 56250 . 56250<em>x</em>2 = 1. 1250 . 1250<em>x</em>2 = 0. 250 . 250<em>x</em>2 = 0. 50 . 50<em>x</em>2 = 1. 0
</p></li>
</ul></li>
</ol>

<h4>
Binary
</h4>

<ul>
<li>
To octal
</li>
<li>
To decimal
</li>
<li>
To hexadecimal
</li>
</ul>

<h4>
Octal
</h4>

<ul>
<li>
To binary
</li>
<li>
To decimal
</li>
<li>
To hexadecimal
</li>
</ul>

<h4>
Decimal
</h4>

<ul>
<li>
To binary
</li>
<li>
To octal
</li>
<li>
To hexadecimal
</li>
</ul>

<h4>
Hexadecimal
</h4>

<ul>
<li>
To decimal
</li>
<li>
To octal
</li>
<li>
To binary
</li>
</ul>

<h3>
Endianess
</h3>

<ul>
<li><p>
There are generally two forms of Endian-ness, <strong>Big Endian</strong> and <strong>Little Endian</strong>.
</p></li>
<li><p>
Endian-ness refers to the ordering of bytes stored in memory, determined by the significance of the byte.
</p></li>
<li><p>
What’s the difference between the two different types?
</p>

<ul>
<li><p>
Little Endian machines store the <strong>least</strong> significant byte first, at the <strong>lowest</strong> byte address
</p>

<ul>
<li>
Most machines that we use in our day-to-day life is Little Endian.
</li>
</ul></li>
<li><p>
Big Endian machines store the <strong>most</strong> significant byte first, at the <strong>lowest</strong> byte address
</p>

<ul>
<li>
Most machines that use Big Endian do not run an architecture that we are likely to come in contact with.
</li>
</ul></li>
</ul></li>
</ul>

<h3>
Assembly Language (x86, AT&amp;T, 32-bit)
</h3>

<ul>
<li><p>
Basic assembly instructions are read from right to left source, right to left destination.
</p>

<ul>
<li>
For example, 96(%ebp, %eax, 8) means “multiply 8 by the memory of eax, add to ebp and then add 96 to that.
</li>
</ul></li>
<li><p>
Parenthesis always denotes memory being used
</p></li>
<li><p>
The difference between leal and mov is mov actually moves the contents, leal simply copies the address but not the contents
</p></li>
<li><p>
Operands can have the following types:
</p>

<ul>
<li><p>
Register: These operands refer directly to the contents of the CPU’s registers, and are denoted with a % in front of them.
</p>

<ul>
<li>
If you want to deal with address, put a ( ) around register
</li>
<li>
Offset can be specified as an immediate
</li>
</ul></li>
</ul></li>
<li><p>
Sample program
</p>

<pre><code>movl $1, -4(%ebp);    // we move 1 into "up four bits" from the base pointer
movl $2, -8(%ebp);    // we move 2 into "up eight bits" from the base pointer
movl -8(%ebp), %eax;  // move what in "up eight bits" from base pointo into eax
addl -4(%ebp), %eax;  // add to it what's "up four bits"
movl %eax, -12(%ebp); // move what's in eax to -12 bits from base pointer
</code></pre></li>
<li><p>
Another sample program
</p>

<pre><code>mov al,[L1];     // copy byte at L1 into AL
mov eax,L1;      // EAX now stores the address of byte at L1
mov [L1],ah;     // copy AH into byte at L1
mov eax,[L6];    // copy double word at L6 into EAX
add eax,[L6];    // EAX = EAX + double word at L6
add [L6],eax;    // double word at L6 += EAX
mov al, [L6];    // copy first byte of double word at L6 into AL
</code></pre></li>
</ul>

<h4>
Basic commands
</h4>

<ul>
<li><p>
<code>MOV</code>
</p>

<ul>
<li><p>
The mov instruction moves data from one location to another, but cannot take two locations in memory as operands. The operands must also be the same size.
</p></li>
<li><p>
Format: mov source, destination
</p></li>
</ul></li>
<li><p>
<code>ADD</code>
</p>

<ul>
<li>
Used to add two integers together
</li>
<li>
Format: add destination, source
</li>
<li><p>
Example:
</p>

<pre><code>add eax, 4 -&gt; eax = eax + 4
add al, ah -&gt; al = al + ah
</code></pre></li>
</ul></li>
<li><p>
<code>SUB</code>
</p>

<ul>
<li>
Used to subtract two integers
</li>
<li>
Format: sub destination, source
</li>
<li><p>
Example:
</p>

<p>
sub bx, 10 -&gt; bx = bx -10 sub ebx, edi -&gt; ebx = ebx – edi
</p></li>
</ul></li>
<li><p>
<code>INC</code>/<code>DEC</code>
</p>

<ul>
<li>
Used to increment or decrement values by one.
</li>
<li>
Since one is implicit operand, code is smaller than for add/sub
</li>
<li><p>
Example:
</p>

<p>
inc ecx -&gt; ecx++ dec dl -&gt; dl—
</p></li>
</ul></li>
</ul>

<h4>
Operand Types
</h4>

<ul>
<li><p>
Immediate
</p>

<ul>
<li>
Constant integer data
</li>
<li>
<code><span class="math">\(0x400&lt;/code&gt;, &lt;code&gt;\)</span>-533</code>
</li>
<li>
Encoded with 1, 2, or 4 bytes
</li>
</ul></li>
<li><p>
Register
</p>

<ul>
<li>
One of 8 integer registers
</li>
<li><p>
<code>%esp</code> and <code>%ebp</code> reserved for special use
</p>

<ul>
<li>
<strong>S</strong> tack <strong>p</strong> ointer
</li>
<li>
<strong>B</strong> ase <strong>p</strong> ointer
</li>
</ul></li>
<li><p>
Others have special uses for particular instructions
</p></li>
</ul></li>
</ul>

<h4>
Memory
</h4>

<ul>
<li>
4 consecutive bytes of memory
</li>
<li>
Various “address modes”
</li>
</ul>

<h4>
Parameter order
</h4>

<ul>
<li>
Source before the destination
</li>
<li>
<code>eax := 5</code> is <code>mov $5, %eax</code>
</li>
</ul>

<h4>
Parameter size
</h4>

<ul>
<li>
<code>q</code> for qword,
</li>
<li>
<code>l</code> for long (dword)
</li>
<li>
<code>w</code> for word
</li>
<li>
<code>b</code> for byte
</li>
</ul>

<h4>
Immediate value sigils
</h4>

<ul>
<li>
Values prefixed with a <code>$</code>
</li>
<li>
registers must be prefixed with a <code>%</code>
</li>
</ul>

<h4>
Registers
</h4>

<ul>
<li>
<code>AX</code> multiply/divide, string load &amp; store
</li>
<li>
<code>CX</code> count for string operations &amp; shifts
</li>
<li>
<code>DX</code> port address for <code>IN</code> and <code>OUT</code>
</li>
<li>
<code>BX</code> index register for <code>MOVE</code>
</li>
<li>
<p><code>SP</code> points to top of stack</p>
<ul>
<li>
<code>BP</code> points to base of stack frame
</li>
<li>
<code>SI</code> points to a source in stream operations
</li>
<li>
<code>DI</code> points to a destination in stream operations
</li>
</ul></li>
</ul>

<h3>
Call stack
</h3>

<h3>
DeMorgan's laws
</h3>

<h3>
Circuits
</h3>

<h3>
Radix
</h3>

<h3>
Computer internals
</h3>

<ul>
<li><p>
CPU,
</p>

<ul>
<li>
registers,
</li>
<li>
a program counter,
</li>
<li><p>
ALU (Arithmetic Logic Unit),
</p>

<ul>
<li>
Gets instructions to do things on floating, bitwise, set point, or comparison operations, and gives the results in a condition code.
</li>
</ul></li>
<li><p>
and a control unit
</p></li>
</ul></li>
<li><p>
Memory,
</p>

<ul>
<li>
any part can be accessed in constant time
</li>
<li>
Addresses are stored in either hex, or octal, points to a specific piece of memory
</li>
</ul></li>
<li><p>
BUS,
</p></li>
<li><p>
I/O devices,
</p>

<ul>
<li>
Mouse
</li>
<li>
Keyboard
</li>
<li>
Screen
</li>
<li>
Magic Trackpad
</li>
<li>
Magic Mouse
</li>
</ul></li>
<li><p>
storage, NIC (network interface cards)
</p></li>
</ul>

<h2>
April 11th, 2013 - Lecture
</h2>

<ul>
<li><p>
What I encourage you to do is to write minituare programs
</p>

<ul>
<li><p>
For example, the .size directives, write a program that does nothing but read those strings of bytes, and turn them into a hex number just to show that I can read these numbers and properly convert them.
</p></li>
<li><p>
With this, you have a piece of code you can trust and transplant and really make sure it works.
</p></li>
<li><p>
This is not a requirement, but it is strongly encouraged
</p></li>
</ul></li>
<li><p>
Moving on, the flags that affect various <code>Y86</code> instructions.
</p>

<pre><code>        zf  sf  of
addl    y   y   y
subl    y   y   y
amdl    y   y   0
xori    y   y   0
mull    y   y   y
readb   y   0   0
readw   y   0   0
</code></pre></li>
</ul>

<h2>
April 15th, 2013 - Programming Assignment 4: Y86 Emulation
</h2>

<h3>
Introduction
</h3>

<p>
This assignment is designed to help you really understand how the fetch-and-execute cycle works as well as the idea of program-as-data. It will require a substantial implementation effort. The usual warning goes double for this assignment: <em>Do not procrastinate</em>.
</p>

<h3>
Y86 Architecture
</h3>

<p>
The Y86 architecture has eight registers, three condition codes, a program counter and memory that holds machine instructions and data. All addresses, immediate values and displacements are 32 bit little-endian values. Each of the eight registers has a 4-bit ID that fits into the Y86 instructions. The eight registers and their encoding in the Y86 machine instructions are as follows:
</p>

<pre><code> %eax 0
 %ecx 1
 %edx 2
 %ebx 3
 %esp 4
 %ebp 5
 %esi 6
 %edi 7
</code></pre>

<p>
The condition codes are single-bit flags set by arithmetic or logical instructions. The three condition codes are:
</p>

<pre><code> OF overflow
 ZF zero
 SF negative
</code></pre>

<p>
The program counter is the address of the next machine instruction to execute. Total memory size will have to be determined as part of emulator execution. The Y86 instruction set is modeled on the larger Intelx86 instruction set, but is not a direct subset.
</p>

<h3>
Y86 Emulator
</h3>

<p>
An emulator is hardware or software that duplicates (or emulates) the functions of one computer system (in this case Y86 instructions) on another computer system (the Intel host). The Y86 instructions are different from the Intel x86 instructions. Your assignment is to write an emulator for the Y86 instruction set.
</p>

<p>
Implement a program y86emul that executes Y86 executable files. Your program y86emul should support the following user interface:
</p>

<pre><code>y86emul [-h] &lt;y86 input file&gt;
</code></pre>

<p>
where <y86 input file> is the name of a Y86 input file, whose structure is defined in Section 5.
</p>

<p>
If -h is given as an argument, your program should just print out help for how the user can run the program and then quit.
</p>

<p>
Erroneous inputs should cause your program to print out:
</p>

<pre><code>ERROR: &lt;an informative error message&gt;
</code></pre>

<p>
Otherwise, your program should run the Y86 code which may read whatever Y86 inputs from the terminal and/or write Y86 outputs to the terminal as your Y86 program executes.
</p>

<p>
Your emulator will read the input file, allocate a chunk of memory of appropriate size which will act as the Y86 address space, populate that chunk of memory with data and machine instructions from the input file and then starts execution of the Y86 machine instructions. The entire address space of the Y86 program fits within this block of allocated memory. The lowest byte of the address of the allocated block is Y86 address 0 and all other Y86 addresses are offsets within this block.
</p>

<p>
Your emulator will fetch, decode and execute Y86 instructions. This execution is tied to an status code that may take on the value AOK, HLT, ADR, INS. AOK means that everything is fine, no detected errors during execution. HLT means a halt instruction has been encountered, which is how Y86 programs normally end. ADR means some sort of invalid address has been encountered, which also stops Y86 program execution. INS is set for an invalid instruction, which also stops Y86 program execution. Your emulator should print out how the Y86 program execution ended.
</p>

<h3>
Y86 Instructions
</h3>

<p>
The definition and encoding of the Y86 instructions are presented in the slides (also an attachment) and in the Bryant and O’Halloran book in Chapter 4.1. The instruction set presented there is minimal and almost functionally complete. What is missing are instructions for input and output. Your Y86 emulator will also handle instruction to read from and write to the terminal.
</p>

<p>
Read byte and read long instructions
</p>

<pre><code>Encoding Bytes 
0 1 2 3 4 5
readb d(rA) C0 rA F D 
readl d(rA) C1 rA F D
</code></pre>

<p>
The readb instruction reads a single byte from the terminal into memory, and the readl instruction reads a single 4-byte little-endian word into memory. The little-endian word is already compatible with the little-endian Intel architecture, where your emulator will run. Both instructions set the ZF condition code. On normal input, the ZF flag is set to zero, on end-of-file the ZF flag is set to one. Testing the conditon code is how the Y86 code can detect end of file. Note that the F in the second half of the second byte means ”no register”, just as it does for some of the other Y86 instructions. Both instructions are six bytes long with a 4-byte offset D.
</p>

<p>
Write byte and write long instructions
</p>

<pre><code>Encoding Bytes 
0 1 2 3 4 5
writeb d(rA) D0 rA F D 
writel d(rA) D1 rA F D
</code></pre>

<p>
The writeb instruction writes a single byte from memory to the terminal, and the writel instruction writes a single 4-byte little-endian word from memory to the terminal. Neither instruction alters the condition codes. Both instructions are six bytes long with a 4-byte offset D.
</p>

<p>
Multiplcation Instruction
</p>

<p>
Encoding Bytes 0 1 2 3 4 5 mull rA,rB 64 D
</p>

<p>
The mull instruction multiplies the values in rA and rB and leaves the product in rB. This instruc- tion set the condition codes. The instruction is five bytes long.
</p>

<h3>
Y86 Input file format
</h3>

<p>
The input file to your Y86 emulator does not contain Y86 assembler instructions. Instead, it contains an ASCII representation of the information needed to start and execute a ready-to-run program, including Y86 machine instructions. An input file will contain directives that specify data and Y86 machine instructions.
</p>

<h4>
Specifying Total Program Size and Base of Stack
</h4>

<p>
The .size directive
</p>

<pre><code>.size hex-address
</code></pre>

<p>
This specifies the total size of the program in memory. The hex address also specifies the address of the bottom of the stack. The Y86 stack grows from larger addresses toward smaller addresses. There should be only one .size directive in the input file.
</p>

<h4>
Specifying String Constants
</h4>

<p>
The .string directive
</p>

<pre><code>.string hex-address "double-quoted string"
</code></pre>

<p>
specifies a string contained in the double quotes. The hex-address specifies the location of the string in the memory block allocated by your emulator. The input string will contain only printable characters and nothing that requires a backslash.
</p>

<h4>
Specifying Integer Values
</h4>

<p>
The .long directive
</p>

<pre><code>.long hex-address decimal-number
</code></pre>

<p>
specifies a 4-byte signed integer. The hex address specifies the location of the value and the decimal number is the initial value at that Y86 address. All Y86 arithmetic is 4-byte signed integer arithmetic.
</p>

<h4>
Setting Aside Chunks of Memory
</h4>

<p>
The .bss directive
</p>

<pre><code>.bss hex-address decimal-size
</code></pre>

<p>
specifies a chunk of uninitialzed memory in the Y86 address space. The hex address specifies the location of the uninitialized chunk and the decimal size specifies the size.
</p>

<h4>
Specifying One-Byte Values
</h4>

<p>
The .byte directive
</p>

<pre><code>.byte hex-address hex-number
</code></pre>

<p>
specifies a one-byte value. The hex address specifies the location of the byte and the initial value is the hex number whose value is between 00 and FF, inclusive.
</p>

<h4>
Specifying Y86 Machine Instructions
</h4>

<p>
The .text directive
</p>

<pre><code>.text hex-address ASCII string of hex Y86 instructions
</code></pre>

<p>
specifies the Y86 machine instructions. The hex address specifies where the machine instructions should be placed in the Y86 address space. This same address is also the initial value of the Y86
</p>

<h2>
April 16th, 2013 - Processor Design I: Sequential Processor (Y86)
</h2>

<ul>
<li><p>
<strong>Instruction Set Architecture</strong> (ISA) is the interface between software and hardware.
</p></li>
<li><p>
Y86 is a simplified ISA modeled after x86.
</p></li>
<li><p>
Processor states
</p>

<ul>
<li>
Program registers are the same as IA32, each 32 bits.
</li>
<li><p>
Three condition codes, <code>OF</code> for overflow, <code>ZF</code> for zero, and <code>SF</code> for negative.
</p></li>
<li><p>
Momery is byte addressable storage array, words stored in little- endian byte order.
</p></li>
</ul></li>
</ul>

<h3>
Instructions
</h3>

<ul>
<li><p>
<code>nop</code>
</p>

<ul>
<li>
no effect
</li>
</ul></li>
<li><p>
<code>halt</code>
</p>

<ul>
<li>
stop execution
</li>
</ul></li>
<li><p>
<code>rrmovl rA, rB</code>
</p>

<ul>
<li>
<code>rB &lt;- rA</code>
</li>
</ul></li>
<li><p>
<code>irmovl V, rb</code>
</p>

<ul>
<li>
<code>rB &lt;- V</code>
</li>
</ul></li>
<li><p>
<code>rmmovl rA, D(rb)</code>
</p>

<ul>
<li>
<code>Mem[rB + D] &lt;- rA</code>
</li>
</ul></li>
<li><p>
<code>mrmovl D(rA), rB</code>
</p>

<ul>
<li>
<code>rb &lt;- Mem[rA + D]</code>
</li>
</ul></li>
<li><p>
<code>OP rA, rB</code>
</p>

<ul>
<li>
<code>rB&lt;-rBOPrA</code> (OP )
</li>
</ul></li>
<li><p>
<code>jXX Dest</code>
</p>

<ul>
<li>
<code>PC &lt;- Dest</code>
</li>
</ul></li>
<li><p>
<code>call Dest</code>
</p>

<ul>
<li>
invoke function at Dest
</li>
</ul></li>
<li><p>
<code>ret</code>
</p>

<ul>
<li>
return from function
</li>
</ul></li>
<li><p>
<code>pushl rA</code>
</p>

<ul>
<li>
<code>%esp &lt;- %esp – 4; Mem[%esp] &lt;- rA</code>
</li>
</ul></li>
<li><p>
<code>popl rA</code>
</p>

<ul>
<li>
<code>rA &lt;- Mem[%esp]; %esp &lt;- %esp + 4</code>
</li>
</ul></li>
</ul>

<h3>
Registers
</h3>

<ul>
<li>
<code>%eax</code> - 0
</li>
<li>
<code>%ecx</code> - 1
</li>
<li>
<code>%edx</code> - 2
</li>
<li>
<code>%ebx</code> - 3
</li>
<li>
<code>%esp</code> - 4
</li>
<li>
<code>%ebp</code> - 5
</li>
<li>
<code>%esi</code> - 6
</li>
<li>
<code>%edi</code> - 7
</li>
</ul>

<h3>
Condition codes
</h3>

<ul>
<li>
<code>OF</code> - overflow
</li>
<li>
<code>ZF</code> - zero
</li>
<li>
<code>SF</code> - negative
</li>
</ul>

<h3>
Error codes
</h3>

<ul>
<li>
<code>AOK</code> - &quot;everything is fine&quot;
</li>
<li>
<code>HLT</code> - &quot;halt instruction has been encountered&quot;
</li>
<li>
<code>ADR</code> - &quot;means some sort of invalid address&quot;
</li>
<li>
<code>INS</code> - &quot;an invalid instruction&quot;
</li>
</ul>

<blockquote>
  <p>
Your emulator should print out how the Y86 program execution ended.
</p>
</blockquote>

<h3>
Directives
</h3>

<h4>
The <code>.size</code> directive
</h4>

<pre><code>.size hex-address
</code></pre>

<ul>
<li>
total size of the program in memory
</li>
<li>
address at the bottom of the stack
</li>
<li>
stack grows from largers addresser toweard smaller address
</li>
<li>
<strong>there can be only one</strong>
</li>
</ul>

<h4>
The <code>.string</code> directive
</h4>

<pre><code>.string hex-address "double-quoted string"
</code></pre>

<ul>
<li><p>
the hex address
</p>

<ul>
<li>
specifies the location of the given string
</li>
</ul></li>
<li><p>
the double-quotes string
</p>

<ul>
<li>
will contain only printable characters
</li>
</ul></li>
<li><p>
This is a contrived string, local to the program.
</p>

<ul>
<li>
To implement, save in an array, it seems.
</li>
</ul></li>
</ul>

<h4>
The <code>.long</code> directive
</h4>

<pre><code>.long hex-address decimal-number
</code></pre>

<ul>
<li>
The hex address specifies the location of the value
</li>
<li>
The decimal number is the initial value at that address.
</li>
<li>
<strong>all arithmatic is 4-byte signed integer arithmatic</strong>
</li>
</ul>

<h4>
The <code>.bss</code> directive
</h4>

<pre><code>.bss hex-address decimal-size
</code></pre>

<ul>
<li>
specifies a chuck of uninitialized memory in Y86 address space
</li>
<li>
the hex address is the location
</li>
<li>
the decimal size is the size
</li>
</ul>

<h4>
The <code>.byte</code> directive
</h4>

<pre><code>.byte hex-address hex-number
</code></pre>

<ul>
<li>
specifies a one-byte value
</li>
<li>
the hex address specifcs the location
</li>
<li>
the hex number is between 00 and FF (inclusive)
</li>
</ul>

<h4>
The <code>.text</code> directive
</h4>

<pre><code>.text hex-address "ASCII string of hex Y86 instructions"
</code></pre>

<ul>
<li><p>
The hex address specifies where the machine instructions should be placed in the Y86 address space.
</p></li>
<li><p>
The ASCII string in a single long encoding of the hex bytes on the machine instructions, two characters per byte, no leading ”0x”.
</p></li>
</ul>

<h3>
Instruction Encoding
</h3>

<pre><code>Byte                0   1   2   3   4   5
nop                 0   0
halt                1   0
rrmovl rA, rB       2   0   rA  rB
irmovl V, rb        3   0   8   rB
rmmovl rA, D(rb)    4   0   rA  rB
mrmovl D(rB), rA    5   0   rA  rB
OPl rA, rB          6   fn  rA  rB
jXX Dest            7   fn  Dest
call Dest           8   0   Dest
ret                 9   0 
pul rA              A   0   rA  8
popl rA             B   0   rA  8
</code></pre>

<ul>
<li><p>
The decimal values of operations (instructions are data):
</p>

<pre><code>+-------------+-----+---+
| Instruction | Hex |Siz|
+-------------+-----+---+
| nop         | 00  | 1 | 
| halt        | 10  | 1 | 
| rrmovl      | 20  | 2 | 
| irmovl      | 30  | 6 |
| rmmovl      | 40  | 6 |
| mrmovl      | 50  | 6 |
| addl        | 60  | 2 |
| subl        | 61  | 2 |
| andl        | 62  | 2 |
| mull        | 64  | 2 |
| xorl        | 63  | 2 |
| jmp         | 70  | 5 |
| jle         | 71  | 5 |
| jl          | 72  | 5 | 
| je          | 73  | 5 |
| jne         | 74  | 5 | 
| jge         | 75  | 5 | 
| jg          | 76  | 5 |
| call        | 80  | 5 |
| ret         | 90  | 1 |
| pushl       | a0  | 2 |
| popl        | b0  | 2 |
+-------------+-----+---+
this chart pushed my vim knowledge to the limit
ask @Tazato
</code></pre></li>
</ul>

<h3>
Summary
</h3>

<ul>
<li>
Similar state and instruction as IA32
</li>
<li>
Simpler encodings
</li>
<li>
Somewhere between CISC and RISC
</li>
</ul>

<h3>
Stages
</h3>

<ul>
<li>
Fetch, read instructions from memory
</li>
<li>
Decode, read operand register
</li>
<li>
Execute, computer value or address
</li>
<li>
Memory, read/write date from/to main memory
</li>
<li>
Write back, write destination register
</li>
<li>
PC, update program counter
</li>
</ul>

<h2>
April 15th, 2013 - Lecture: Memory
</h2>

<ul>
<li><p>
RAM
</p>

<ul>
<li><p>
Key features
</p>

<ul>
<li>
RAM is packaged as a chip
</li>
<li>
Basic storage unit is a cell
</li>
<li>
Multiple RAM chips form a memory
</li>
</ul></li>
<li><p>
Static RAM (SRAM)
</p>

<ul>
<li>
Each cell stores bit with a six-transistor circuit
</li>
<li>
Retains value indefinitely, as long as it is kept powered
</li>
<li>
Relative insnsitive to disturbances
</li>
<li>
Faster and more expensive than DRAM
</li>
</ul></li>
<li><p>
Dynamic RAM (DRAM)
</p>

<ul>
<li>
Each cell stores bit with a capacitor and transistor
</li>
<li>
Value must be refereshed every 10-100ms
</li>
<li>
Sensitive to disturbances
</li>
<li>
Slower and cheaper than SRAM
</li>
</ul></li>
</ul></li>
</ul> 
{% endraw %}